// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_POOL_H_
#define FLATBUFFERS_GENERATED_POOL_H_

#include "flatbuffers/flatbuffers.h"

struct PoolInfo;
struct PoolInfoT;

struct Block;
struct BlockT;

struct BlockTemplate;
struct BlockTemplateT;

struct GetBlockByHashReq;
struct GetBlockByHashReqT;

struct GetBlockByHashResult;
struct GetBlockByHashResultT;

struct ProofOfWorkReq;
struct ProofOfWorkReqT;

struct ProofOfWorkResult;
struct ProofOfWorkResultT;

struct GetBalanceResult;
struct GetBalanceResultT;

struct SendMoneyReq;
struct SendMoneyReqT;

struct SendMoneyResult;
struct SendMoneyResultT;

struct ListUnspentElement;
struct ListUnspentElementT;

struct ZDestination;
struct ZDestinationT;

struct AsyncOperationStatus;
struct AsyncOperationStatusT;

struct WalletReq;
struct WalletReqT;

struct WalletResult;
struct WalletResultT;

struct PoolBalance;
struct PoolBalanceT;

struct ClientInfo;
struct ClientInfoT;

struct PayoutRecord;
struct PayoutRecordT;

struct WorkerStatsRecord;
struct WorkerStatsRecordT;

struct WorkerStatsAggregate;
struct WorkerStatsAggregateT;

struct Query;
struct QueryT;

struct QueryResult;
struct QueryResultT;

struct Share;
struct ShareT;

struct Stats;
struct StatsT;

struct RoundElement;
struct RoundElementT;

struct Round;
struct RoundT;

struct P2PMessage;
struct P2PMessageT;

struct Signal;
struct SignalT;

enum FunctionId {
  FunctionId_None = 0,
  FunctionId_GetInfo = 1,
  FunctionId_GetCurrentBlock = 2,
  FunctionId_GetBlockTemplate = 3,
  FunctionId_GetBlockByHash = 4,
  FunctionId_SendProofOfWork = 5,
  FunctionId_GetBalance = 6,
  FunctionId_SendMoney = 7,
  FunctionId_ZGetBalance = 8,
  FunctionId_ZSendMoney = 9,
  FunctionId_ListUnspent = 10,
  FunctionId_ZAsyncOperationStatus = 11,
  FunctionId_QueryFoundBlocks = 12,
  FunctionId_QueryClientInfo = 13,
  FunctionId_UpdateClientInfo = 14,
  FunctionId_QueryPoolBalance = 15,
  FunctionId_QueryPayouts = 16,
  FunctionId_QueryClientStats = 17,
  FunctionId_QueryPoolStats = 18,
  FunctionId_QueryWorkerStatsHistory = 19,
  FunctionId_QueryClientStatsHistory = 20,
  FunctionId_QueryPoolStatsHistory = 21,
  FunctionId_ResendBrokenTx = 22,
  FunctionId_MoveBalance = 23,
  FunctionId_ManualPayout = 24,
  FunctionId_Share = 25,
  FunctionId_Stats = 26,
  FunctionId_MIN = FunctionId_None,
  FunctionId_MAX = FunctionId_Stats
};

inline const char **EnumNamesFunctionId() {
  static const char *names[] = { "None", "GetInfo", "GetCurrentBlock", "GetBlockTemplate", "GetBlockByHash", "SendProofOfWork", "GetBalance", "SendMoney", "ZGetBalance", "ZSendMoney", "ListUnspent", "ZAsyncOperationStatus", "QueryFoundBlocks", "QueryClientInfo", "UpdateClientInfo", "QueryPoolBalance", "QueryPayouts", "QueryClientStats", "QueryPoolStats", "QueryWorkerStatsHistory", "QueryClientStatsHistory", "QueryPoolStatsHistory", "ResendBrokenTx", "MoveBalance", "ManualPayout", "Share", "Stats", nullptr };
  return names;
}

inline const char *EnumNameFunctionId(FunctionId e) { return EnumNamesFunctionId()[static_cast<int>(e)]; }

enum SignalId {
  SignalId_None = 0,
  SignalId_NewBlock = 1,
  SignalId_MIN = SignalId_None,
  SignalId_MAX = SignalId_NewBlock
};

inline const char **EnumNamesSignalId() {
  static const char *names[] = { "None", "NewBlock", nullptr };
  return names;
}

inline const char *EnumNameSignalId(SignalId e) { return EnumNamesSignalId()[static_cast<int>(e)]; }

enum GroupByType {
  GroupByType_None = 0,
  GroupByType_Hour = 1,
  GroupByType_Day = 2,
  GroupByType_Week = 3,
  GroupByType_Month = 4,
  GroupByType_MIN = GroupByType_None,
  GroupByType_MAX = GroupByType_Month
};

inline const char **EnumNamesGroupByType() {
  static const char *names[] = { "None", "Hour", "Day", "Week", "Month", nullptr };
  return names;
}

inline const char *EnumNameGroupByType(GroupByType e) { return EnumNamesGroupByType()[static_cast<int>(e)]; }

enum UnitType {
  UnitType_CPU = 0,
  UnitType_GPU = 1,
  UnitType_ASIC = 2,
  UnitType_OTHER = 3,
  UnitType_MIN = UnitType_CPU,
  UnitType_MAX = UnitType_OTHER
};

inline const char **EnumNamesUnitType() {
  static const char *names[] = { "CPU", "GPU", "ASIC", "OTHER", nullptr };
  return names;
}

inline const char *EnumNameUnitType(UnitType e) { return EnumNamesUnitType()[static_cast<int>(e)]; }

enum AsyncOpState {
  AsyncOpState_READY = 0,
  AsyncOpState_EXECUTING = 1,
  AsyncOpState_CANCELLED = 2,
  AsyncOpState_FAILED = 3,
  AsyncOpState_SUCCESS = 4,
  AsyncOpState_MIN = AsyncOpState_READY,
  AsyncOpState_MAX = AsyncOpState_SUCCESS
};

inline const char **EnumNamesAsyncOpState() {
  static const char *names[] = { "READY", "EXECUTING", "CANCELLED", "FAILED", "SUCCESS", nullptr };
  return names;
}

inline const char *EnumNameAsyncOpState(AsyncOpState e) { return EnumNamesAsyncOpState()[static_cast<int>(e)]; }

enum Data {
  Data_NONE = 0,
  Data_PoolInfo = 1,
  Data_Block = 2,
  Data_BlockTemplate = 3,
  Data_GetBlockByHashReq = 4,
  Data_ProofOfWorkReq = 5,
  Data_SendMoneyReq = 6,
  Data_WalletReq = 7,
  Data_Query = 8,
  Data_QueryResult = 9,
  Data_Share = 10,
  Data_Stats = 11,
  Data_MIN = Data_NONE,
  Data_MAX = Data_Stats
};

struct DataUnion {
  Data type;

  flatbuffers::NativeTable *table;
  DataUnion() : type(Data_NONE), table(nullptr) {}
  DataUnion(const DataUnion &);
  DataUnion &operator=(const DataUnion &);
  ~DataUnion();

  static flatbuffers::NativeTable *UnPack(const void *union_obj, Data type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *rehasher = nullptr) const;

  PoolInfoT *AsPoolInfo() { return type == Data_PoolInfo ? reinterpret_cast<PoolInfoT *>(table) : nullptr; }
  BlockT *AsBlock() { return type == Data_Block ? reinterpret_cast<BlockT *>(table) : nullptr; }
  BlockTemplateT *AsBlockTemplate() { return type == Data_BlockTemplate ? reinterpret_cast<BlockTemplateT *>(table) : nullptr; }
  GetBlockByHashReqT *AsGetBlockByHashReq() { return type == Data_GetBlockByHashReq ? reinterpret_cast<GetBlockByHashReqT *>(table) : nullptr; }
  ProofOfWorkReqT *AsProofOfWorkReq() { return type == Data_ProofOfWorkReq ? reinterpret_cast<ProofOfWorkReqT *>(table) : nullptr; }
  SendMoneyReqT *AsSendMoneyReq() { return type == Data_SendMoneyReq ? reinterpret_cast<SendMoneyReqT *>(table) : nullptr; }
  WalletReqT *AsWalletReq() { return type == Data_WalletReq ? reinterpret_cast<WalletReqT *>(table) : nullptr; }
  QueryT *AsQuery() { return type == Data_Query ? reinterpret_cast<QueryT *>(table) : nullptr; }
  QueryResultT *AsQueryResult() { return type == Data_QueryResult ? reinterpret_cast<QueryResultT *>(table) : nullptr; }
  ShareT *AsShare() { return type == Data_Share ? reinterpret_cast<ShareT *>(table) : nullptr; }
  StatsT *AsStats() { return type == Data_Stats ? reinterpret_cast<StatsT *>(table) : nullptr; }
};

inline const char **EnumNamesData() {
  static const char *names[] = { "NONE", "PoolInfo", "Block", "BlockTemplate", "GetBlockByHashReq", "ProofOfWorkReq", "SendMoneyReq", "WalletReq", "Query", "QueryResult", "Share", "Stats", nullptr };
  return names;
}

inline const char *EnumNameData(Data e) { return EnumNamesData()[static_cast<int>(e)]; }

template<typename T> struct DataTraits {
  static const Data enum_value = Data_NONE;
};

template<> struct DataTraits<PoolInfo> {
  static const Data enum_value = Data_PoolInfo;
};

template<> struct DataTraits<Block> {
  static const Data enum_value = Data_Block;
};

template<> struct DataTraits<BlockTemplate> {
  static const Data enum_value = Data_BlockTemplate;
};

template<> struct DataTraits<GetBlockByHashReq> {
  static const Data enum_value = Data_GetBlockByHashReq;
};

template<> struct DataTraits<ProofOfWorkReq> {
  static const Data enum_value = Data_ProofOfWorkReq;
};

template<> struct DataTraits<SendMoneyReq> {
  static const Data enum_value = Data_SendMoneyReq;
};

template<> struct DataTraits<WalletReq> {
  static const Data enum_value = Data_WalletReq;
};

template<> struct DataTraits<Query> {
  static const Data enum_value = Data_Query;
};

template<> struct DataTraits<QueryResult> {
  static const Data enum_value = Data_QueryResult;
};

template<> struct DataTraits<Share> {
  static const Data enum_value = Data_Share;
};

template<> struct DataTraits<Stats> {
  static const Data enum_value = Data_Stats;
};

inline bool VerifyData(flatbuffers::Verifier &verifier, const void *union_obj, Data type);

struct PoolInfoT : public flatbuffers::NativeTable {
  std::string coin;
};

struct PoolInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COIN = 4
  };
  const flatbuffers::String *coin() const { return GetPointer<const flatbuffers::String *>(VT_COIN); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COIN) &&
           verifier.Verify(coin()) &&
           verifier.EndTable();
  }
  PoolInfoT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct PoolInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coin(flatbuffers::Offset<flatbuffers::String> coin) { fbb_.AddOffset(PoolInfo::VT_COIN, coin); }
  PoolInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PoolInfoBuilder &operator=(const PoolInfoBuilder &);
  flatbuffers::Offset<PoolInfo> Finish() {
    auto o = flatbuffers::Offset<PoolInfo>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<PoolInfo> CreatePoolInfo(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> coin = 0) {
  PoolInfoBuilder builder_(_fbb);
  builder_.add_coin(coin);
  return builder_.Finish();
}

inline flatbuffers::Offset<PoolInfo> CreatePoolInfoDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *coin = nullptr) {
  return CreatePoolInfo(_fbb, coin ? _fbb.CreateString(coin) : 0);
}

inline flatbuffers::Offset<PoolInfo> CreatePoolInfo(flatbuffers::FlatBufferBuilder &_fbb, const PoolInfoT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct BlockT : public flatbuffers::NativeTable {
  int64_t height;
  int64_t bits;
  std::string hash;
  std::string prevhash;
  std::string merkle;
  int64_t time;
  std::string hashreserved;
  int32_t equilHashK;
  int32_t equilHashN;
  int64_t confirmations;
  int64_t generatedCoins;
  std::string foundBy;
};

struct Block FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEIGHT = 4,
    VT_BITS = 6,
    VT_HASH = 8,
    VT_PREVHASH = 10,
    VT_MERKLE = 12,
    VT_TIME = 14,
    VT_HASHRESERVED = 16,
    VT_EQUILHASHK = 18,
    VT_EQUILHASHN = 20,
    VT_CONFIRMATIONS = 22,
    VT_GENERATEDCOINS = 24,
    VT_FOUNDBY = 26
  };
  int64_t height() const { return GetField<int64_t>(VT_HEIGHT, 0); }
  int64_t bits() const { return GetField<int64_t>(VT_BITS, 0); }
  const flatbuffers::String *hash() const { return GetPointer<const flatbuffers::String *>(VT_HASH); }
  const flatbuffers::String *prevhash() const { return GetPointer<const flatbuffers::String *>(VT_PREVHASH); }
  const flatbuffers::String *merkle() const { return GetPointer<const flatbuffers::String *>(VT_MERKLE); }
  int64_t time() const { return GetField<int64_t>(VT_TIME, 0); }
  const flatbuffers::String *hashreserved() const { return GetPointer<const flatbuffers::String *>(VT_HASHRESERVED); }
  int32_t equilHashK() const { return GetField<int32_t>(VT_EQUILHASHK, -1); }
  int32_t equilHashN() const { return GetField<int32_t>(VT_EQUILHASHN, -1); }
  int64_t confirmations() const { return GetField<int64_t>(VT_CONFIRMATIONS, 0); }
  int64_t generatedCoins() const { return GetField<int64_t>(VT_GENERATEDCOINS, 0); }
  const flatbuffers::String *foundBy() const { return GetPointer<const flatbuffers::String *>(VT_FOUNDBY); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_HEIGHT) &&
           VerifyField<int64_t>(verifier, VT_BITS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PREVHASH) &&
           verifier.Verify(prevhash()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MERKLE) &&
           verifier.Verify(merkle()) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HASHRESERVED) &&
           verifier.Verify(hashreserved()) &&
           VerifyField<int32_t>(verifier, VT_EQUILHASHK) &&
           VerifyField<int32_t>(verifier, VT_EQUILHASHN) &&
           VerifyField<int64_t>(verifier, VT_CONFIRMATIONS) &&
           VerifyField<int64_t>(verifier, VT_GENERATEDCOINS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FOUNDBY) &&
           verifier.Verify(foundBy()) &&
           verifier.EndTable();
  }
  BlockT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct BlockBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(int64_t height) { fbb_.AddElement<int64_t>(Block::VT_HEIGHT, height, 0); }
  void add_bits(int64_t bits) { fbb_.AddElement<int64_t>(Block::VT_BITS, bits, 0); }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) { fbb_.AddOffset(Block::VT_HASH, hash); }
  void add_prevhash(flatbuffers::Offset<flatbuffers::String> prevhash) { fbb_.AddOffset(Block::VT_PREVHASH, prevhash); }
  void add_merkle(flatbuffers::Offset<flatbuffers::String> merkle) { fbb_.AddOffset(Block::VT_MERKLE, merkle); }
  void add_time(int64_t time) { fbb_.AddElement<int64_t>(Block::VT_TIME, time, 0); }
  void add_hashreserved(flatbuffers::Offset<flatbuffers::String> hashreserved) { fbb_.AddOffset(Block::VT_HASHRESERVED, hashreserved); }
  void add_equilHashK(int32_t equilHashK) { fbb_.AddElement<int32_t>(Block::VT_EQUILHASHK, equilHashK, -1); }
  void add_equilHashN(int32_t equilHashN) { fbb_.AddElement<int32_t>(Block::VT_EQUILHASHN, equilHashN, -1); }
  void add_confirmations(int64_t confirmations) { fbb_.AddElement<int64_t>(Block::VT_CONFIRMATIONS, confirmations, 0); }
  void add_generatedCoins(int64_t generatedCoins) { fbb_.AddElement<int64_t>(Block::VT_GENERATEDCOINS, generatedCoins, 0); }
  void add_foundBy(flatbuffers::Offset<flatbuffers::String> foundBy) { fbb_.AddOffset(Block::VT_FOUNDBY, foundBy); }
  BlockBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BlockBuilder &operator=(const BlockBuilder &);
  flatbuffers::Offset<Block> Finish() {
    auto o = flatbuffers::Offset<Block>(fbb_.EndTable(start_, 12));
    return o;
  }
};

inline flatbuffers::Offset<Block> CreateBlock(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t height = 0,
    int64_t bits = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0,
    flatbuffers::Offset<flatbuffers::String> prevhash = 0,
    flatbuffers::Offset<flatbuffers::String> merkle = 0,
    int64_t time = 0,
    flatbuffers::Offset<flatbuffers::String> hashreserved = 0,
    int32_t equilHashK = -1,
    int32_t equilHashN = -1,
    int64_t confirmations = 0,
    int64_t generatedCoins = 0,
    flatbuffers::Offset<flatbuffers::String> foundBy = 0) {
  BlockBuilder builder_(_fbb);
  builder_.add_generatedCoins(generatedCoins);
  builder_.add_confirmations(confirmations);
  builder_.add_time(time);
  builder_.add_bits(bits);
  builder_.add_height(height);
  builder_.add_foundBy(foundBy);
  builder_.add_equilHashN(equilHashN);
  builder_.add_equilHashK(equilHashK);
  builder_.add_hashreserved(hashreserved);
  builder_.add_merkle(merkle);
  builder_.add_prevhash(prevhash);
  builder_.add_hash(hash);
  return builder_.Finish();
}

inline flatbuffers::Offset<Block> CreateBlockDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t height = 0,
    int64_t bits = 0,
    const char *hash = nullptr,
    const char *prevhash = nullptr,
    const char *merkle = nullptr,
    int64_t time = 0,
    const char *hashreserved = nullptr,
    int32_t equilHashK = -1,
    int32_t equilHashN = -1,
    int64_t confirmations = 0,
    int64_t generatedCoins = 0,
    const char *foundBy = nullptr) {
  return CreateBlock(_fbb, height, bits, hash ? _fbb.CreateString(hash) : 0, prevhash ? _fbb.CreateString(prevhash) : 0, merkle ? _fbb.CreateString(merkle) : 0, time, hashreserved ? _fbb.CreateString(hashreserved) : 0, equilHashK, equilHashN, confirmations, generatedCoins, foundBy ? _fbb.CreateString(foundBy) : 0);
}

inline flatbuffers::Offset<Block> CreateBlock(flatbuffers::FlatBufferBuilder &_fbb, const BlockT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct BlockTemplateT : public flatbuffers::NativeTable {
  std::string prevhash;
  std::string merkle;
  int64_t bits;
  int64_t time;
  int64_t extraNonce;
  std::string hashreserved;
  int32_t equilHashK;
  int32_t equilHashN;
};

struct BlockTemplate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PREVHASH = 4,
    VT_MERKLE = 6,
    VT_BITS = 8,
    VT_TIME = 10,
    VT_EXTRANONCE = 12,
    VT_HASHRESERVED = 14,
    VT_EQUILHASHK = 16,
    VT_EQUILHASHN = 18
  };
  const flatbuffers::String *prevhash() const { return GetPointer<const flatbuffers::String *>(VT_PREVHASH); }
  const flatbuffers::String *merkle() const { return GetPointer<const flatbuffers::String *>(VT_MERKLE); }
  int64_t bits() const { return GetField<int64_t>(VT_BITS, 0); }
  int64_t time() const { return GetField<int64_t>(VT_TIME, 0); }
  int64_t extraNonce() const { return GetField<int64_t>(VT_EXTRANONCE, 0); }
  const flatbuffers::String *hashreserved() const { return GetPointer<const flatbuffers::String *>(VT_HASHRESERVED); }
  int32_t equilHashK() const { return GetField<int32_t>(VT_EQUILHASHK, -1); }
  int32_t equilHashN() const { return GetField<int32_t>(VT_EQUILHASHN, -1); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PREVHASH) &&
           verifier.Verify(prevhash()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MERKLE) &&
           verifier.Verify(merkle()) &&
           VerifyField<int64_t>(verifier, VT_BITS) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyField<int64_t>(verifier, VT_EXTRANONCE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HASHRESERVED) &&
           verifier.Verify(hashreserved()) &&
           VerifyField<int32_t>(verifier, VT_EQUILHASHK) &&
           VerifyField<int32_t>(verifier, VT_EQUILHASHN) &&
           verifier.EndTable();
  }
  BlockTemplateT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct BlockTemplateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prevhash(flatbuffers::Offset<flatbuffers::String> prevhash) { fbb_.AddOffset(BlockTemplate::VT_PREVHASH, prevhash); }
  void add_merkle(flatbuffers::Offset<flatbuffers::String> merkle) { fbb_.AddOffset(BlockTemplate::VT_MERKLE, merkle); }
  void add_bits(int64_t bits) { fbb_.AddElement<int64_t>(BlockTemplate::VT_BITS, bits, 0); }
  void add_time(int64_t time) { fbb_.AddElement<int64_t>(BlockTemplate::VT_TIME, time, 0); }
  void add_extraNonce(int64_t extraNonce) { fbb_.AddElement<int64_t>(BlockTemplate::VT_EXTRANONCE, extraNonce, 0); }
  void add_hashreserved(flatbuffers::Offset<flatbuffers::String> hashreserved) { fbb_.AddOffset(BlockTemplate::VT_HASHRESERVED, hashreserved); }
  void add_equilHashK(int32_t equilHashK) { fbb_.AddElement<int32_t>(BlockTemplate::VT_EQUILHASHK, equilHashK, -1); }
  void add_equilHashN(int32_t equilHashN) { fbb_.AddElement<int32_t>(BlockTemplate::VT_EQUILHASHN, equilHashN, -1); }
  BlockTemplateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BlockTemplateBuilder &operator=(const BlockTemplateBuilder &);
  flatbuffers::Offset<BlockTemplate> Finish() {
    auto o = flatbuffers::Offset<BlockTemplate>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<BlockTemplate> CreateBlockTemplate(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> prevhash = 0,
    flatbuffers::Offset<flatbuffers::String> merkle = 0,
    int64_t bits = 0,
    int64_t time = 0,
    int64_t extraNonce = 0,
    flatbuffers::Offset<flatbuffers::String> hashreserved = 0,
    int32_t equilHashK = -1,
    int32_t equilHashN = -1) {
  BlockTemplateBuilder builder_(_fbb);
  builder_.add_extraNonce(extraNonce);
  builder_.add_time(time);
  builder_.add_bits(bits);
  builder_.add_equilHashN(equilHashN);
  builder_.add_equilHashK(equilHashK);
  builder_.add_hashreserved(hashreserved);
  builder_.add_merkle(merkle);
  builder_.add_prevhash(prevhash);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlockTemplate> CreateBlockTemplateDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *prevhash = nullptr,
    const char *merkle = nullptr,
    int64_t bits = 0,
    int64_t time = 0,
    int64_t extraNonce = 0,
    const char *hashreserved = nullptr,
    int32_t equilHashK = -1,
    int32_t equilHashN = -1) {
  return CreateBlockTemplate(_fbb, prevhash ? _fbb.CreateString(prevhash) : 0, merkle ? _fbb.CreateString(merkle) : 0, bits, time, extraNonce, hashreserved ? _fbb.CreateString(hashreserved) : 0, equilHashK, equilHashN);
}

inline flatbuffers::Offset<BlockTemplate> CreateBlockTemplate(flatbuffers::FlatBufferBuilder &_fbb, const BlockTemplateT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct GetBlockByHashReqT : public flatbuffers::NativeTable {
  std::vector<std::string> hashes;
};

struct GetBlockByHashReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HASHES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *hashes() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HASHES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HASHES) &&
           verifier.Verify(hashes()) &&
           verifier.VerifyVectorOfStrings(hashes()) &&
           verifier.EndTable();
  }
  GetBlockByHashReqT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct GetBlockByHashReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hashes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> hashes) { fbb_.AddOffset(GetBlockByHashReq::VT_HASHES, hashes); }
  GetBlockByHashReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GetBlockByHashReqBuilder &operator=(const GetBlockByHashReqBuilder &);
  flatbuffers::Offset<GetBlockByHashReq> Finish() {
    auto o = flatbuffers::Offset<GetBlockByHashReq>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<GetBlockByHashReq> CreateGetBlockByHashReq(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> hashes = 0) {
  GetBlockByHashReqBuilder builder_(_fbb);
  builder_.add_hashes(hashes);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetBlockByHashReq> CreateGetBlockByHashReqDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *hashes = nullptr) {
  return CreateGetBlockByHashReq(_fbb, hashes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*hashes) : 0);
}

inline flatbuffers::Offset<GetBlockByHashReq> CreateGetBlockByHashReq(flatbuffers::FlatBufferBuilder &_fbb, const GetBlockByHashReqT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct GetBlockByHashResultT : public flatbuffers::NativeTable {
  std::vector<std::unique_ptr<BlockT>> blocks;
};

struct GetBlockByHashResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BLOCKS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Block>> *blocks() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Block>> *>(VT_BLOCKS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BLOCKS) &&
           verifier.Verify(blocks()) &&
           verifier.VerifyVectorOfTables(blocks()) &&
           verifier.EndTable();
  }
  GetBlockByHashResultT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct GetBlockByHashResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blocks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Block>>> blocks) { fbb_.AddOffset(GetBlockByHashResult::VT_BLOCKS, blocks); }
  GetBlockByHashResultBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GetBlockByHashResultBuilder &operator=(const GetBlockByHashResultBuilder &);
  flatbuffers::Offset<GetBlockByHashResult> Finish() {
    auto o = flatbuffers::Offset<GetBlockByHashResult>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<GetBlockByHashResult> CreateGetBlockByHashResult(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Block>>> blocks = 0) {
  GetBlockByHashResultBuilder builder_(_fbb);
  builder_.add_blocks(blocks);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetBlockByHashResult> CreateGetBlockByHashResultDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Block>> *blocks = nullptr) {
  return CreateGetBlockByHashResult(_fbb, blocks ? _fbb.CreateVector<flatbuffers::Offset<Block>>(*blocks) : 0);
}

inline flatbuffers::Offset<GetBlockByHashResult> CreateGetBlockByHashResult(flatbuffers::FlatBufferBuilder &_fbb, const GetBlockByHashResultT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct ProofOfWorkReqT : public flatbuffers::NativeTable {
  int64_t height;
  int64_t time;
  std::string nonce;
  int64_t extraNonce;
  std::string data;
};

struct ProofOfWorkReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEIGHT = 4,
    VT_TIME = 6,
    VT_NONCE = 8,
    VT_EXTRANONCE = 10,
    VT_DATA = 12
  };
  int64_t height() const { return GetField<int64_t>(VT_HEIGHT, 0); }
  int64_t time() const { return GetField<int64_t>(VT_TIME, 0); }
  const flatbuffers::String *nonce() const { return GetPointer<const flatbuffers::String *>(VT_NONCE); }
  int64_t extraNonce() const { return GetField<int64_t>(VT_EXTRANONCE, 0); }
  const flatbuffers::String *data() const { return GetPointer<const flatbuffers::String *>(VT_DATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_HEIGHT) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NONCE) &&
           verifier.Verify(nonce()) &&
           VerifyField<int64_t>(verifier, VT_EXTRANONCE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
  ProofOfWorkReqT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct ProofOfWorkReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(int64_t height) { fbb_.AddElement<int64_t>(ProofOfWorkReq::VT_HEIGHT, height, 0); }
  void add_time(int64_t time) { fbb_.AddElement<int64_t>(ProofOfWorkReq::VT_TIME, time, 0); }
  void add_nonce(flatbuffers::Offset<flatbuffers::String> nonce) { fbb_.AddOffset(ProofOfWorkReq::VT_NONCE, nonce); }
  void add_extraNonce(int64_t extraNonce) { fbb_.AddElement<int64_t>(ProofOfWorkReq::VT_EXTRANONCE, extraNonce, 0); }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) { fbb_.AddOffset(ProofOfWorkReq::VT_DATA, data); }
  ProofOfWorkReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ProofOfWorkReqBuilder &operator=(const ProofOfWorkReqBuilder &);
  flatbuffers::Offset<ProofOfWorkReq> Finish() {
    auto o = flatbuffers::Offset<ProofOfWorkReq>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<ProofOfWorkReq> CreateProofOfWorkReq(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t height = 0,
    int64_t time = 0,
    flatbuffers::Offset<flatbuffers::String> nonce = 0,
    int64_t extraNonce = 0,
    flatbuffers::Offset<flatbuffers::String> data = 0) {
  ProofOfWorkReqBuilder builder_(_fbb);
  builder_.add_extraNonce(extraNonce);
  builder_.add_time(time);
  builder_.add_height(height);
  builder_.add_data(data);
  builder_.add_nonce(nonce);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProofOfWorkReq> CreateProofOfWorkReqDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t height = 0,
    int64_t time = 0,
    const char *nonce = nullptr,
    int64_t extraNonce = 0,
    const char *data = nullptr) {
  return CreateProofOfWorkReq(_fbb, height, time, nonce ? _fbb.CreateString(nonce) : 0, extraNonce, data ? _fbb.CreateString(data) : 0);
}

inline flatbuffers::Offset<ProofOfWorkReq> CreateProofOfWorkReq(flatbuffers::FlatBufferBuilder &_fbb, const ProofOfWorkReqT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct ProofOfWorkResultT : public flatbuffers::NativeTable {
  bool result;
  int64_t generatedCoins;
};

struct ProofOfWorkResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_GENERATEDCOINS = 6
  };
  bool result() const { return GetField<uint8_t>(VT_RESULT, 0) != 0; }
  int64_t generatedCoins() const { return GetField<int64_t>(VT_GENERATEDCOINS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESULT) &&
           VerifyField<int64_t>(verifier, VT_GENERATEDCOINS) &&
           verifier.EndTable();
  }
  ProofOfWorkResultT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct ProofOfWorkResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(bool result) { fbb_.AddElement<uint8_t>(ProofOfWorkResult::VT_RESULT, static_cast<uint8_t>(result), 0); }
  void add_generatedCoins(int64_t generatedCoins) { fbb_.AddElement<int64_t>(ProofOfWorkResult::VT_GENERATEDCOINS, generatedCoins, 0); }
  ProofOfWorkResultBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ProofOfWorkResultBuilder &operator=(const ProofOfWorkResultBuilder &);
  flatbuffers::Offset<ProofOfWorkResult> Finish() {
    auto o = flatbuffers::Offset<ProofOfWorkResult>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ProofOfWorkResult> CreateProofOfWorkResult(flatbuffers::FlatBufferBuilder &_fbb,
    bool result = false,
    int64_t generatedCoins = 0) {
  ProofOfWorkResultBuilder builder_(_fbb);
  builder_.add_generatedCoins(generatedCoins);
  builder_.add_result(result);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProofOfWorkResult> CreateProofOfWorkResult(flatbuffers::FlatBufferBuilder &_fbb, const ProofOfWorkResultT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct GetBalanceResultT : public flatbuffers::NativeTable {
  int64_t balance;
  int64_t immature;
};

struct GetBalanceResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BALANCE = 4,
    VT_IMMATURE = 6
  };
  int64_t balance() const { return GetField<int64_t>(VT_BALANCE, 0); }
  int64_t immature() const { return GetField<int64_t>(VT_IMMATURE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BALANCE) &&
           VerifyField<int64_t>(verifier, VT_IMMATURE) &&
           verifier.EndTable();
  }
  GetBalanceResultT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct GetBalanceResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_balance(int64_t balance) { fbb_.AddElement<int64_t>(GetBalanceResult::VT_BALANCE, balance, 0); }
  void add_immature(int64_t immature) { fbb_.AddElement<int64_t>(GetBalanceResult::VT_IMMATURE, immature, 0); }
  GetBalanceResultBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GetBalanceResultBuilder &operator=(const GetBalanceResultBuilder &);
  flatbuffers::Offset<GetBalanceResult> Finish() {
    auto o = flatbuffers::Offset<GetBalanceResult>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<GetBalanceResult> CreateGetBalanceResult(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t balance = 0,
    int64_t immature = 0) {
  GetBalanceResultBuilder builder_(_fbb);
  builder_.add_immature(immature);
  builder_.add_balance(balance);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetBalanceResult> CreateGetBalanceResult(flatbuffers::FlatBufferBuilder &_fbb, const GetBalanceResultT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct SendMoneyReqT : public flatbuffers::NativeTable {
  std::string destination;
  int64_t amount;
};

struct SendMoneyReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DESTINATION = 4,
    VT_AMOUNT = 6
  };
  const flatbuffers::String *destination() const { return GetPointer<const flatbuffers::String *>(VT_DESTINATION); }
  int64_t amount() const { return GetField<int64_t>(VT_AMOUNT, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DESTINATION) &&
           verifier.Verify(destination()) &&
           VerifyField<int64_t>(verifier, VT_AMOUNT) &&
           verifier.EndTable();
  }
  SendMoneyReqT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct SendMoneyReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_destination(flatbuffers::Offset<flatbuffers::String> destination) { fbb_.AddOffset(SendMoneyReq::VT_DESTINATION, destination); }
  void add_amount(int64_t amount) { fbb_.AddElement<int64_t>(SendMoneyReq::VT_AMOUNT, amount, 0); }
  SendMoneyReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SendMoneyReqBuilder &operator=(const SendMoneyReqBuilder &);
  flatbuffers::Offset<SendMoneyReq> Finish() {
    auto o = flatbuffers::Offset<SendMoneyReq>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<SendMoneyReq> CreateSendMoneyReq(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> destination = 0,
    int64_t amount = 0) {
  SendMoneyReqBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_destination(destination);
  return builder_.Finish();
}

inline flatbuffers::Offset<SendMoneyReq> CreateSendMoneyReqDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *destination = nullptr,
    int64_t amount = 0) {
  return CreateSendMoneyReq(_fbb, destination ? _fbb.CreateString(destination) : 0, amount);
}

inline flatbuffers::Offset<SendMoneyReq> CreateSendMoneyReq(flatbuffers::FlatBufferBuilder &_fbb, const SendMoneyReqT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct SendMoneyResultT : public flatbuffers::NativeTable {
  bool success;
  std::string txid;
  int64_t remaining;
  int64_t fee;
  std::string error;
};

struct SendMoneyResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SUCCESS = 4,
    VT_TXID = 6,
    VT_REMAINING = 8,
    VT_FEE = 10,
    VT_ERROR = 12
  };
  bool success() const { return GetField<uint8_t>(VT_SUCCESS, 0) != 0; }
  const flatbuffers::String *txid() const { return GetPointer<const flatbuffers::String *>(VT_TXID); }
  int64_t remaining() const { return GetField<int64_t>(VT_REMAINING, 0); }
  int64_t fee() const { return GetField<int64_t>(VT_FEE, 0); }
  const flatbuffers::String *error() const { return GetPointer<const flatbuffers::String *>(VT_ERROR); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TXID) &&
           verifier.Verify(txid()) &&
           VerifyField<int64_t>(verifier, VT_REMAINING) &&
           VerifyField<int64_t>(verifier, VT_FEE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ERROR) &&
           verifier.Verify(error()) &&
           verifier.EndTable();
  }
  SendMoneyResultT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct SendMoneyResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) { fbb_.AddElement<uint8_t>(SendMoneyResult::VT_SUCCESS, static_cast<uint8_t>(success), 0); }
  void add_txid(flatbuffers::Offset<flatbuffers::String> txid) { fbb_.AddOffset(SendMoneyResult::VT_TXID, txid); }
  void add_remaining(int64_t remaining) { fbb_.AddElement<int64_t>(SendMoneyResult::VT_REMAINING, remaining, 0); }
  void add_fee(int64_t fee) { fbb_.AddElement<int64_t>(SendMoneyResult::VT_FEE, fee, 0); }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) { fbb_.AddOffset(SendMoneyResult::VT_ERROR, error); }
  SendMoneyResultBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SendMoneyResultBuilder &operator=(const SendMoneyResultBuilder &);
  flatbuffers::Offset<SendMoneyResult> Finish() {
    auto o = flatbuffers::Offset<SendMoneyResult>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<SendMoneyResult> CreateSendMoneyResult(flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    flatbuffers::Offset<flatbuffers::String> txid = 0,
    int64_t remaining = 0,
    int64_t fee = 0,
    flatbuffers::Offset<flatbuffers::String> error = 0) {
  SendMoneyResultBuilder builder_(_fbb);
  builder_.add_fee(fee);
  builder_.add_remaining(remaining);
  builder_.add_error(error);
  builder_.add_txid(txid);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<SendMoneyResult> CreateSendMoneyResultDirect(flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    const char *txid = nullptr,
    int64_t remaining = 0,
    int64_t fee = 0,
    const char *error = nullptr) {
  return CreateSendMoneyResult(_fbb, success, txid ? _fbb.CreateString(txid) : 0, remaining, fee, error ? _fbb.CreateString(error) : 0);
}

inline flatbuffers::Offset<SendMoneyResult> CreateSendMoneyResult(flatbuffers::FlatBufferBuilder &_fbb, const SendMoneyResultT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct ListUnspentElementT : public flatbuffers::NativeTable {
  std::string address;
  int64_t amount;
  int32_t confirmations;
  bool spendable;
};

struct ListUnspentElement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS = 4,
    VT_AMOUNT = 6,
    VT_CONFIRMATIONS = 8,
    VT_SPENDABLE = 10
  };
  const flatbuffers::String *address() const { return GetPointer<const flatbuffers::String *>(VT_ADDRESS); }
  int64_t amount() const { return GetField<int64_t>(VT_AMOUNT, 0); }
  int32_t confirmations() const { return GetField<int32_t>(VT_CONFIRMATIONS, 0); }
  bool spendable() const { return GetField<uint8_t>(VT_SPENDABLE, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<int64_t>(verifier, VT_AMOUNT) &&
           VerifyField<int32_t>(verifier, VT_CONFIRMATIONS) &&
           VerifyField<uint8_t>(verifier, VT_SPENDABLE) &&
           verifier.EndTable();
  }
  ListUnspentElementT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct ListUnspentElementBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::String> address) { fbb_.AddOffset(ListUnspentElement::VT_ADDRESS, address); }
  void add_amount(int64_t amount) { fbb_.AddElement<int64_t>(ListUnspentElement::VT_AMOUNT, amount, 0); }
  void add_confirmations(int32_t confirmations) { fbb_.AddElement<int32_t>(ListUnspentElement::VT_CONFIRMATIONS, confirmations, 0); }
  void add_spendable(bool spendable) { fbb_.AddElement<uint8_t>(ListUnspentElement::VT_SPENDABLE, static_cast<uint8_t>(spendable), 0); }
  ListUnspentElementBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ListUnspentElementBuilder &operator=(const ListUnspentElementBuilder &);
  flatbuffers::Offset<ListUnspentElement> Finish() {
    auto o = flatbuffers::Offset<ListUnspentElement>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<ListUnspentElement> CreateListUnspentElement(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    int64_t amount = 0,
    int32_t confirmations = 0,
    bool spendable = false) {
  ListUnspentElementBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_confirmations(confirmations);
  builder_.add_address(address);
  builder_.add_spendable(spendable);
  return builder_.Finish();
}

inline flatbuffers::Offset<ListUnspentElement> CreateListUnspentElementDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    int64_t amount = 0,
    int32_t confirmations = 0,
    bool spendable = false) {
  return CreateListUnspentElement(_fbb, address ? _fbb.CreateString(address) : 0, amount, confirmations, spendable);
}

inline flatbuffers::Offset<ListUnspentElement> CreateListUnspentElement(flatbuffers::FlatBufferBuilder &_fbb, const ListUnspentElementT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct ZDestinationT : public flatbuffers::NativeTable {
  std::string address;
  int64_t amount;
  std::string memo;
};

struct ZDestination FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS = 4,
    VT_AMOUNT = 6,
    VT_MEMO = 8
  };
  const flatbuffers::String *address() const { return GetPointer<const flatbuffers::String *>(VT_ADDRESS); }
  int64_t amount() const { return GetField<int64_t>(VT_AMOUNT, 0); }
  const flatbuffers::String *memo() const { return GetPointer<const flatbuffers::String *>(VT_MEMO); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<int64_t>(verifier, VT_AMOUNT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MEMO) &&
           verifier.Verify(memo()) &&
           verifier.EndTable();
  }
  ZDestinationT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct ZDestinationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::String> address) { fbb_.AddOffset(ZDestination::VT_ADDRESS, address); }
  void add_amount(int64_t amount) { fbb_.AddElement<int64_t>(ZDestination::VT_AMOUNT, amount, 0); }
  void add_memo(flatbuffers::Offset<flatbuffers::String> memo) { fbb_.AddOffset(ZDestination::VT_MEMO, memo); }
  ZDestinationBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ZDestinationBuilder &operator=(const ZDestinationBuilder &);
  flatbuffers::Offset<ZDestination> Finish() {
    auto o = flatbuffers::Offset<ZDestination>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<ZDestination> CreateZDestination(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    int64_t amount = 0,
    flatbuffers::Offset<flatbuffers::String> memo = 0) {
  ZDestinationBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_memo(memo);
  builder_.add_address(address);
  return builder_.Finish();
}

inline flatbuffers::Offset<ZDestination> CreateZDestinationDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    int64_t amount = 0,
    const char *memo = nullptr) {
  return CreateZDestination(_fbb, address ? _fbb.CreateString(address) : 0, amount, memo ? _fbb.CreateString(memo) : 0);
}

inline flatbuffers::Offset<ZDestination> CreateZDestination(flatbuffers::FlatBufferBuilder &_fbb, const ZDestinationT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct AsyncOperationStatusT : public flatbuffers::NativeTable {
  std::string id;
  AsyncOpState state;
  int64_t creationTime;
  std::string txid;
  std::string error;
};

struct AsyncOperationStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_STATE = 6,
    VT_CREATIONTIME = 8,
    VT_TXID = 10,
    VT_ERROR = 12
  };
  const flatbuffers::String *id() const { return GetPointer<const flatbuffers::String *>(VT_ID); }
  AsyncOpState state() const { return static_cast<AsyncOpState>(GetField<int32_t>(VT_STATE, 0)); }
  int64_t creationTime() const { return GetField<int64_t>(VT_CREATIONTIME, 0); }
  const flatbuffers::String *txid() const { return GetPointer<const flatbuffers::String *>(VT_TXID); }
  const flatbuffers::String *error() const { return GetPointer<const flatbuffers::String *>(VT_ERROR); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ID) &&
           verifier.Verify(id()) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           VerifyField<int64_t>(verifier, VT_CREATIONTIME) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TXID) &&
           verifier.Verify(txid()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ERROR) &&
           verifier.Verify(error()) &&
           verifier.EndTable();
  }
  AsyncOperationStatusT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct AsyncOperationStatusBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) { fbb_.AddOffset(AsyncOperationStatus::VT_ID, id); }
  void add_state(AsyncOpState state) { fbb_.AddElement<int32_t>(AsyncOperationStatus::VT_STATE, static_cast<int32_t>(state), 0); }
  void add_creationTime(int64_t creationTime) { fbb_.AddElement<int64_t>(AsyncOperationStatus::VT_CREATIONTIME, creationTime, 0); }
  void add_txid(flatbuffers::Offset<flatbuffers::String> txid) { fbb_.AddOffset(AsyncOperationStatus::VT_TXID, txid); }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) { fbb_.AddOffset(AsyncOperationStatus::VT_ERROR, error); }
  AsyncOperationStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AsyncOperationStatusBuilder &operator=(const AsyncOperationStatusBuilder &);
  flatbuffers::Offset<AsyncOperationStatus> Finish() {
    auto o = flatbuffers::Offset<AsyncOperationStatus>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<AsyncOperationStatus> CreateAsyncOperationStatus(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    AsyncOpState state = AsyncOpState_READY,
    int64_t creationTime = 0,
    flatbuffers::Offset<flatbuffers::String> txid = 0,
    flatbuffers::Offset<flatbuffers::String> error = 0) {
  AsyncOperationStatusBuilder builder_(_fbb);
  builder_.add_creationTime(creationTime);
  builder_.add_error(error);
  builder_.add_txid(txid);
  builder_.add_state(state);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<AsyncOperationStatus> CreateAsyncOperationStatusDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    AsyncOpState state = AsyncOpState_READY,
    int64_t creationTime = 0,
    const char *txid = nullptr,
    const char *error = nullptr) {
  return CreateAsyncOperationStatus(_fbb, id ? _fbb.CreateString(id) : 0, state, creationTime, txid ? _fbb.CreateString(txid) : 0, error ? _fbb.CreateString(error) : 0);
}

inline flatbuffers::Offset<AsyncOperationStatus> CreateAsyncOperationStatus(flatbuffers::FlatBufferBuilder &_fbb, const AsyncOperationStatusT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct WalletReqT : public flatbuffers::NativeTable {
  std::string singleAddress;
  std::string singleAsyncOperationId;
  std::vector<std::unique_ptr<ZDestinationT>> destinations;
};

struct WalletReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SINGLEADDRESS = 4,
    VT_SINGLEASYNCOPERATIONID = 6,
    VT_DESTINATIONS = 8
  };
  const flatbuffers::String *singleAddress() const { return GetPointer<const flatbuffers::String *>(VT_SINGLEADDRESS); }
  const flatbuffers::String *singleAsyncOperationId() const { return GetPointer<const flatbuffers::String *>(VT_SINGLEASYNCOPERATIONID); }
  const flatbuffers::Vector<flatbuffers::Offset<ZDestination>> *destinations() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ZDestination>> *>(VT_DESTINATIONS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SINGLEADDRESS) &&
           verifier.Verify(singleAddress()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SINGLEASYNCOPERATIONID) &&
           verifier.Verify(singleAsyncOperationId()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DESTINATIONS) &&
           verifier.Verify(destinations()) &&
           verifier.VerifyVectorOfTables(destinations()) &&
           verifier.EndTable();
  }
  WalletReqT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct WalletReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_singleAddress(flatbuffers::Offset<flatbuffers::String> singleAddress) { fbb_.AddOffset(WalletReq::VT_SINGLEADDRESS, singleAddress); }
  void add_singleAsyncOperationId(flatbuffers::Offset<flatbuffers::String> singleAsyncOperationId) { fbb_.AddOffset(WalletReq::VT_SINGLEASYNCOPERATIONID, singleAsyncOperationId); }
  void add_destinations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ZDestination>>> destinations) { fbb_.AddOffset(WalletReq::VT_DESTINATIONS, destinations); }
  WalletReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  WalletReqBuilder &operator=(const WalletReqBuilder &);
  flatbuffers::Offset<WalletReq> Finish() {
    auto o = flatbuffers::Offset<WalletReq>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<WalletReq> CreateWalletReq(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> singleAddress = 0,
    flatbuffers::Offset<flatbuffers::String> singleAsyncOperationId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ZDestination>>> destinations = 0) {
  WalletReqBuilder builder_(_fbb);
  builder_.add_destinations(destinations);
  builder_.add_singleAsyncOperationId(singleAsyncOperationId);
  builder_.add_singleAddress(singleAddress);
  return builder_.Finish();
}

inline flatbuffers::Offset<WalletReq> CreateWalletReqDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *singleAddress = nullptr,
    const char *singleAsyncOperationId = nullptr,
    const std::vector<flatbuffers::Offset<ZDestination>> *destinations = nullptr) {
  return CreateWalletReq(_fbb, singleAddress ? _fbb.CreateString(singleAddress) : 0, singleAsyncOperationId ? _fbb.CreateString(singleAsyncOperationId) : 0, destinations ? _fbb.CreateVector<flatbuffers::Offset<ZDestination>>(*destinations) : 0);
}

inline flatbuffers::Offset<WalletReq> CreateWalletReq(flatbuffers::FlatBufferBuilder &_fbb, const WalletReqT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct WalletResultT : public flatbuffers::NativeTable {
  int64_t balance;
  std::string asyncOperationId;
  std::vector<std::unique_ptr<ListUnspentElementT>> outs;
  std::vector<std::unique_ptr<AsyncOperationStatusT>> status;
  std::string error;
};

struct WalletResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BALANCE = 4,
    VT_ASYNCOPERATIONID = 6,
    VT_OUTS = 8,
    VT_STATUS = 10,
    VT_ERROR = 12
  };
  int64_t balance() const { return GetField<int64_t>(VT_BALANCE, 0); }
  const flatbuffers::String *asyncOperationId() const { return GetPointer<const flatbuffers::String *>(VT_ASYNCOPERATIONID); }
  const flatbuffers::Vector<flatbuffers::Offset<ListUnspentElement>> *outs() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ListUnspentElement>> *>(VT_OUTS); }
  const flatbuffers::Vector<flatbuffers::Offset<AsyncOperationStatus>> *status() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AsyncOperationStatus>> *>(VT_STATUS); }
  const flatbuffers::String *error() const { return GetPointer<const flatbuffers::String *>(VT_ERROR); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BALANCE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ASYNCOPERATIONID) &&
           verifier.Verify(asyncOperationId()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OUTS) &&
           verifier.Verify(outs()) &&
           verifier.VerifyVectorOfTables(outs()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_STATUS) &&
           verifier.Verify(status()) &&
           verifier.VerifyVectorOfTables(status()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ERROR) &&
           verifier.Verify(error()) &&
           verifier.EndTable();
  }
  WalletResultT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct WalletResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_balance(int64_t balance) { fbb_.AddElement<int64_t>(WalletResult::VT_BALANCE, balance, 0); }
  void add_asyncOperationId(flatbuffers::Offset<flatbuffers::String> asyncOperationId) { fbb_.AddOffset(WalletResult::VT_ASYNCOPERATIONID, asyncOperationId); }
  void add_outs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ListUnspentElement>>> outs) { fbb_.AddOffset(WalletResult::VT_OUTS, outs); }
  void add_status(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AsyncOperationStatus>>> status) { fbb_.AddOffset(WalletResult::VT_STATUS, status); }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) { fbb_.AddOffset(WalletResult::VT_ERROR, error); }
  WalletResultBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  WalletResultBuilder &operator=(const WalletResultBuilder &);
  flatbuffers::Offset<WalletResult> Finish() {
    auto o = flatbuffers::Offset<WalletResult>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<WalletResult> CreateWalletResult(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t balance = 0,
    flatbuffers::Offset<flatbuffers::String> asyncOperationId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ListUnspentElement>>> outs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AsyncOperationStatus>>> status = 0,
    flatbuffers::Offset<flatbuffers::String> error = 0) {
  WalletResultBuilder builder_(_fbb);
  builder_.add_balance(balance);
  builder_.add_error(error);
  builder_.add_status(status);
  builder_.add_outs(outs);
  builder_.add_asyncOperationId(asyncOperationId);
  return builder_.Finish();
}

inline flatbuffers::Offset<WalletResult> CreateWalletResultDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t balance = 0,
    const char *asyncOperationId = nullptr,
    const std::vector<flatbuffers::Offset<ListUnspentElement>> *outs = nullptr,
    const std::vector<flatbuffers::Offset<AsyncOperationStatus>> *status = nullptr,
    const char *error = nullptr) {
  return CreateWalletResult(_fbb, balance, asyncOperationId ? _fbb.CreateString(asyncOperationId) : 0, outs ? _fbb.CreateVector<flatbuffers::Offset<ListUnspentElement>>(*outs) : 0, status ? _fbb.CreateVector<flatbuffers::Offset<AsyncOperationStatus>>(*status) : 0, error ? _fbb.CreateString(error) : 0);
}

inline flatbuffers::Offset<WalletResult> CreateWalletResult(flatbuffers::FlatBufferBuilder &_fbb, const WalletResultT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct PoolBalanceT : public flatbuffers::NativeTable {
  int64_t time;
  int64_t balance;
  int64_t immature;
  int64_t users;
  int64_t queued;
  int64_t net;
};

struct PoolBalance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIME = 4,
    VT_BALANCE = 6,
    VT_IMMATURE = 8,
    VT_USERS = 10,
    VT_QUEUED = 12,
    VT_NET = 14
  };
  int64_t time() const { return GetField<int64_t>(VT_TIME, 0); }
  int64_t balance() const { return GetField<int64_t>(VT_BALANCE, 0); }
  int64_t immature() const { return GetField<int64_t>(VT_IMMATURE, 0); }
  int64_t users() const { return GetField<int64_t>(VT_USERS, 0); }
  int64_t queued() const { return GetField<int64_t>(VT_QUEUED, 0); }
  int64_t net() const { return GetField<int64_t>(VT_NET, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyField<int64_t>(verifier, VT_BALANCE) &&
           VerifyField<int64_t>(verifier, VT_IMMATURE) &&
           VerifyField<int64_t>(verifier, VT_USERS) &&
           VerifyField<int64_t>(verifier, VT_QUEUED) &&
           VerifyField<int64_t>(verifier, VT_NET) &&
           verifier.EndTable();
  }
  PoolBalanceT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct PoolBalanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) { fbb_.AddElement<int64_t>(PoolBalance::VT_TIME, time, 0); }
  void add_balance(int64_t balance) { fbb_.AddElement<int64_t>(PoolBalance::VT_BALANCE, balance, 0); }
  void add_immature(int64_t immature) { fbb_.AddElement<int64_t>(PoolBalance::VT_IMMATURE, immature, 0); }
  void add_users(int64_t users) { fbb_.AddElement<int64_t>(PoolBalance::VT_USERS, users, 0); }
  void add_queued(int64_t queued) { fbb_.AddElement<int64_t>(PoolBalance::VT_QUEUED, queued, 0); }
  void add_net(int64_t net) { fbb_.AddElement<int64_t>(PoolBalance::VT_NET, net, 0); }
  PoolBalanceBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PoolBalanceBuilder &operator=(const PoolBalanceBuilder &);
  flatbuffers::Offset<PoolBalance> Finish() {
    auto o = flatbuffers::Offset<PoolBalance>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<PoolBalance> CreatePoolBalance(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0,
    int64_t balance = 0,
    int64_t immature = 0,
    int64_t users = 0,
    int64_t queued = 0,
    int64_t net = 0) {
  PoolBalanceBuilder builder_(_fbb);
  builder_.add_net(net);
  builder_.add_queued(queued);
  builder_.add_users(users);
  builder_.add_immature(immature);
  builder_.add_balance(balance);
  builder_.add_time(time);
  return builder_.Finish();
}

inline flatbuffers::Offset<PoolBalance> CreatePoolBalance(flatbuffers::FlatBufferBuilder &_fbb, const PoolBalanceT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct ClientInfoT : public flatbuffers::NativeTable {
  int64_t balance;
  int64_t requested;
  int64_t paid;
  std::string name;
  std::string email;
  int64_t minimalPayout;
};

struct ClientInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BALANCE = 4,
    VT_REQUESTED = 6,
    VT_PAID = 8,
    VT_NAME = 10,
    VT_EMAIL = 12,
    VT_MINIMALPAYOUT = 14
  };
  int64_t balance() const { return GetField<int64_t>(VT_BALANCE, 0); }
  int64_t requested() const { return GetField<int64_t>(VT_REQUESTED, 0); }
  int64_t paid() const { return GetField<int64_t>(VT_PAID, 0); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const flatbuffers::String *email() const { return GetPointer<const flatbuffers::String *>(VT_EMAIL); }
  int64_t minimalPayout() const { return GetField<int64_t>(VT_MINIMALPAYOUT, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BALANCE) &&
           VerifyField<int64_t>(verifier, VT_REQUESTED) &&
           VerifyField<int64_t>(verifier, VT_PAID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EMAIL) &&
           verifier.Verify(email()) &&
           VerifyField<int64_t>(verifier, VT_MINIMALPAYOUT) &&
           verifier.EndTable();
  }
  ClientInfoT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct ClientInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_balance(int64_t balance) { fbb_.AddElement<int64_t>(ClientInfo::VT_BALANCE, balance, 0); }
  void add_requested(int64_t requested) { fbb_.AddElement<int64_t>(ClientInfo::VT_REQUESTED, requested, 0); }
  void add_paid(int64_t paid) { fbb_.AddElement<int64_t>(ClientInfo::VT_PAID, paid, 0); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(ClientInfo::VT_NAME, name); }
  void add_email(flatbuffers::Offset<flatbuffers::String> email) { fbb_.AddOffset(ClientInfo::VT_EMAIL, email); }
  void add_minimalPayout(int64_t minimalPayout) { fbb_.AddElement<int64_t>(ClientInfo::VT_MINIMALPAYOUT, minimalPayout, 0); }
  ClientInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ClientInfoBuilder &operator=(const ClientInfoBuilder &);
  flatbuffers::Offset<ClientInfo> Finish() {
    auto o = flatbuffers::Offset<ClientInfo>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<ClientInfo> CreateClientInfo(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t balance = 0,
    int64_t requested = 0,
    int64_t paid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> email = 0,
    int64_t minimalPayout = 0) {
  ClientInfoBuilder builder_(_fbb);
  builder_.add_minimalPayout(minimalPayout);
  builder_.add_paid(paid);
  builder_.add_requested(requested);
  builder_.add_balance(balance);
  builder_.add_email(email);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClientInfo> CreateClientInfoDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t balance = 0,
    int64_t requested = 0,
    int64_t paid = 0,
    const char *name = nullptr,
    const char *email = nullptr,
    int64_t minimalPayout = 0) {
  return CreateClientInfo(_fbb, balance, requested, paid, name ? _fbb.CreateString(name) : 0, email ? _fbb.CreateString(email) : 0, minimalPayout);
}

inline flatbuffers::Offset<ClientInfo> CreateClientInfo(flatbuffers::FlatBufferBuilder &_fbb, const ClientInfoT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct PayoutRecordT : public flatbuffers::NativeTable {
  std::string timeLabel;
  int64_t time;
  int64_t value;
  std::string txid;
};

struct PayoutRecord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMELABEL = 4,
    VT_TIME = 6,
    VT_VALUE = 8,
    VT_TXID = 10
  };
  const flatbuffers::String *timeLabel() const { return GetPointer<const flatbuffers::String *>(VT_TIMELABEL); }
  int64_t time() const { return GetField<int64_t>(VT_TIME, 0); }
  int64_t value() const { return GetField<int64_t>(VT_VALUE, 0); }
  const flatbuffers::String *txid() const { return GetPointer<const flatbuffers::String *>(VT_TXID); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TIMELABEL) &&
           verifier.Verify(timeLabel()) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TXID) &&
           verifier.Verify(txid()) &&
           verifier.EndTable();
  }
  PayoutRecordT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct PayoutRecordBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timeLabel(flatbuffers::Offset<flatbuffers::String> timeLabel) { fbb_.AddOffset(PayoutRecord::VT_TIMELABEL, timeLabel); }
  void add_time(int64_t time) { fbb_.AddElement<int64_t>(PayoutRecord::VT_TIME, time, 0); }
  void add_value(int64_t value) { fbb_.AddElement<int64_t>(PayoutRecord::VT_VALUE, value, 0); }
  void add_txid(flatbuffers::Offset<flatbuffers::String> txid) { fbb_.AddOffset(PayoutRecord::VT_TXID, txid); }
  PayoutRecordBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PayoutRecordBuilder &operator=(const PayoutRecordBuilder &);
  flatbuffers::Offset<PayoutRecord> Finish() {
    auto o = flatbuffers::Offset<PayoutRecord>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<PayoutRecord> CreatePayoutRecord(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> timeLabel = 0,
    int64_t time = 0,
    int64_t value = 0,
    flatbuffers::Offset<flatbuffers::String> txid = 0) {
  PayoutRecordBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_time(time);
  builder_.add_txid(txid);
  builder_.add_timeLabel(timeLabel);
  return builder_.Finish();
}

inline flatbuffers::Offset<PayoutRecord> CreatePayoutRecordDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *timeLabel = nullptr,
    int64_t time = 0,
    int64_t value = 0,
    const char *txid = nullptr) {
  return CreatePayoutRecord(_fbb, timeLabel ? _fbb.CreateString(timeLabel) : 0, time, value, txid ? _fbb.CreateString(txid) : 0);
}

inline flatbuffers::Offset<PayoutRecord> CreatePayoutRecord(flatbuffers::FlatBufferBuilder &_fbb, const PayoutRecordT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct WorkerStatsRecordT : public flatbuffers::NativeTable {
  std::string name;
  int64_t time;
  std::string address;
  int64_t power;
  int32_t latency;
  UnitType type;
  int32_t units;
  int32_t temp;
};

struct WorkerStatsRecord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_TIME = 6,
    VT_ADDRESS = 8,
    VT_POWER = 10,
    VT_LATENCY = 12,
    VT_TYPE = 14,
    VT_UNITS = 16,
    VT_TEMP = 18
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  int64_t time() const { return GetField<int64_t>(VT_TIME, 0); }
  const flatbuffers::String *address() const { return GetPointer<const flatbuffers::String *>(VT_ADDRESS); }
  int64_t power() const { return GetField<int64_t>(VT_POWER, 0); }
  int32_t latency() const { return GetField<int32_t>(VT_LATENCY, 0); }
  UnitType type() const { return static_cast<UnitType>(GetField<int32_t>(VT_TYPE, 0)); }
  int32_t units() const { return GetField<int32_t>(VT_UNITS, 0); }
  int32_t temp() const { return GetField<int32_t>(VT_TEMP, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<int64_t>(verifier, VT_POWER) &&
           VerifyField<int32_t>(verifier, VT_LATENCY) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_UNITS) &&
           VerifyField<int32_t>(verifier, VT_TEMP) &&
           verifier.EndTable();
  }
  WorkerStatsRecordT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct WorkerStatsRecordBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(WorkerStatsRecord::VT_NAME, name); }
  void add_time(int64_t time) { fbb_.AddElement<int64_t>(WorkerStatsRecord::VT_TIME, time, 0); }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) { fbb_.AddOffset(WorkerStatsRecord::VT_ADDRESS, address); }
  void add_power(int64_t power) { fbb_.AddElement<int64_t>(WorkerStatsRecord::VT_POWER, power, 0); }
  void add_latency(int32_t latency) { fbb_.AddElement<int32_t>(WorkerStatsRecord::VT_LATENCY, latency, 0); }
  void add_type(UnitType type) { fbb_.AddElement<int32_t>(WorkerStatsRecord::VT_TYPE, static_cast<int32_t>(type), 0); }
  void add_units(int32_t units) { fbb_.AddElement<int32_t>(WorkerStatsRecord::VT_UNITS, units, 0); }
  void add_temp(int32_t temp) { fbb_.AddElement<int32_t>(WorkerStatsRecord::VT_TEMP, temp, 0); }
  WorkerStatsRecordBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  WorkerStatsRecordBuilder &operator=(const WorkerStatsRecordBuilder &);
  flatbuffers::Offset<WorkerStatsRecord> Finish() {
    auto o = flatbuffers::Offset<WorkerStatsRecord>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<WorkerStatsRecord> CreateWorkerStatsRecord(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int64_t time = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    int64_t power = 0,
    int32_t latency = 0,
    UnitType type = UnitType_CPU,
    int32_t units = 0,
    int32_t temp = 0) {
  WorkerStatsRecordBuilder builder_(_fbb);
  builder_.add_power(power);
  builder_.add_time(time);
  builder_.add_temp(temp);
  builder_.add_units(units);
  builder_.add_type(type);
  builder_.add_latency(latency);
  builder_.add_address(address);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkerStatsRecord> CreateWorkerStatsRecordDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int64_t time = 0,
    const char *address = nullptr,
    int64_t power = 0,
    int32_t latency = 0,
    UnitType type = UnitType_CPU,
    int32_t units = 0,
    int32_t temp = 0) {
  return CreateWorkerStatsRecord(_fbb, name ? _fbb.CreateString(name) : 0, time, address ? _fbb.CreateString(address) : 0, power, latency, type, units, temp);
}

inline flatbuffers::Offset<WorkerStatsRecord> CreateWorkerStatsRecord(flatbuffers::FlatBufferBuilder &_fbb, const WorkerStatsRecordT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct WorkerStatsAggregateT : public flatbuffers::NativeTable {
  int64_t time;
  int64_t clients;
  int64_t workers;
  int64_t cpus;
  int64_t gpus;
  int64_t asics;
  int64_t other;
  int32_t avgerageLatency;
  int64_t power;
};

struct WorkerStatsAggregate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIME = 4,
    VT_CLIENTS = 6,
    VT_WORKERS = 8,
    VT_CPUS = 10,
    VT_GPUS = 12,
    VT_ASICS = 14,
    VT_OTHER = 16,
    VT_AVGERAGELATENCY = 18,
    VT_POWER = 20
  };
  int64_t time() const { return GetField<int64_t>(VT_TIME, 0); }
  int64_t clients() const { return GetField<int64_t>(VT_CLIENTS, 0); }
  int64_t workers() const { return GetField<int64_t>(VT_WORKERS, 0); }
  int64_t cpus() const { return GetField<int64_t>(VT_CPUS, 0); }
  int64_t gpus() const { return GetField<int64_t>(VT_GPUS, 0); }
  int64_t asics() const { return GetField<int64_t>(VT_ASICS, 0); }
  int64_t other() const { return GetField<int64_t>(VT_OTHER, 0); }
  int32_t avgerageLatency() const { return GetField<int32_t>(VT_AVGERAGELATENCY, 0); }
  int64_t power() const { return GetField<int64_t>(VT_POWER, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyField<int64_t>(verifier, VT_CLIENTS) &&
           VerifyField<int64_t>(verifier, VT_WORKERS) &&
           VerifyField<int64_t>(verifier, VT_CPUS) &&
           VerifyField<int64_t>(verifier, VT_GPUS) &&
           VerifyField<int64_t>(verifier, VT_ASICS) &&
           VerifyField<int64_t>(verifier, VT_OTHER) &&
           VerifyField<int32_t>(verifier, VT_AVGERAGELATENCY) &&
           VerifyField<int64_t>(verifier, VT_POWER) &&
           verifier.EndTable();
  }
  WorkerStatsAggregateT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct WorkerStatsAggregateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) { fbb_.AddElement<int64_t>(WorkerStatsAggregate::VT_TIME, time, 0); }
  void add_clients(int64_t clients) { fbb_.AddElement<int64_t>(WorkerStatsAggregate::VT_CLIENTS, clients, 0); }
  void add_workers(int64_t workers) { fbb_.AddElement<int64_t>(WorkerStatsAggregate::VT_WORKERS, workers, 0); }
  void add_cpus(int64_t cpus) { fbb_.AddElement<int64_t>(WorkerStatsAggregate::VT_CPUS, cpus, 0); }
  void add_gpus(int64_t gpus) { fbb_.AddElement<int64_t>(WorkerStatsAggregate::VT_GPUS, gpus, 0); }
  void add_asics(int64_t asics) { fbb_.AddElement<int64_t>(WorkerStatsAggregate::VT_ASICS, asics, 0); }
  void add_other(int64_t other) { fbb_.AddElement<int64_t>(WorkerStatsAggregate::VT_OTHER, other, 0); }
  void add_avgerageLatency(int32_t avgerageLatency) { fbb_.AddElement<int32_t>(WorkerStatsAggregate::VT_AVGERAGELATENCY, avgerageLatency, 0); }
  void add_power(int64_t power) { fbb_.AddElement<int64_t>(WorkerStatsAggregate::VT_POWER, power, 0); }
  WorkerStatsAggregateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  WorkerStatsAggregateBuilder &operator=(const WorkerStatsAggregateBuilder &);
  flatbuffers::Offset<WorkerStatsAggregate> Finish() {
    auto o = flatbuffers::Offset<WorkerStatsAggregate>(fbb_.EndTable(start_, 9));
    return o;
  }
};

inline flatbuffers::Offset<WorkerStatsAggregate> CreateWorkerStatsAggregate(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0,
    int64_t clients = 0,
    int64_t workers = 0,
    int64_t cpus = 0,
    int64_t gpus = 0,
    int64_t asics = 0,
    int64_t other = 0,
    int32_t avgerageLatency = 0,
    int64_t power = 0) {
  WorkerStatsAggregateBuilder builder_(_fbb);
  builder_.add_power(power);
  builder_.add_other(other);
  builder_.add_asics(asics);
  builder_.add_gpus(gpus);
  builder_.add_cpus(cpus);
  builder_.add_workers(workers);
  builder_.add_clients(clients);
  builder_.add_time(time);
  builder_.add_avgerageLatency(avgerageLatency);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkerStatsAggregate> CreateWorkerStatsAggregate(flatbuffers::FlatBufferBuilder &_fbb, const WorkerStatsAggregateT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct QueryT : public flatbuffers::NativeTable {
  std::string userId;
  std::string workerId;
  int64_t count;
  int64_t heightFrom;
  int64_t timeFrom;
  std::string hashFrom;
  GroupByType groupBy;
  std::unique_ptr<ClientInfoT> clientInfo;
  std::string targetUserId;
};

struct Query FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_USERID = 4,
    VT_WORKERID = 6,
    VT_COUNT = 8,
    VT_HEIGHTFROM = 10,
    VT_TIMEFROM = 12,
    VT_HASHFROM = 14,
    VT_GROUPBY = 16,
    VT_CLIENTINFO = 18,
    VT_TARGETUSERID = 20
  };
  const flatbuffers::String *userId() const { return GetPointer<const flatbuffers::String *>(VT_USERID); }
  const flatbuffers::String *workerId() const { return GetPointer<const flatbuffers::String *>(VT_WORKERID); }
  int64_t count() const { return GetField<int64_t>(VT_COUNT, 0); }
  int64_t heightFrom() const { return GetField<int64_t>(VT_HEIGHTFROM, 0); }
  int64_t timeFrom() const { return GetField<int64_t>(VT_TIMEFROM, 0); }
  const flatbuffers::String *hashFrom() const { return GetPointer<const flatbuffers::String *>(VT_HASHFROM); }
  GroupByType groupBy() const { return static_cast<GroupByType>(GetField<int32_t>(VT_GROUPBY, 0)); }
  const ClientInfo *clientInfo() const { return GetPointer<const ClientInfo *>(VT_CLIENTINFO); }
  const flatbuffers::String *targetUserId() const { return GetPointer<const flatbuffers::String *>(VT_TARGETUSERID); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_USERID) &&
           verifier.Verify(userId()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_WORKERID) &&
           verifier.Verify(workerId()) &&
           VerifyField<int64_t>(verifier, VT_COUNT) &&
           VerifyField<int64_t>(verifier, VT_HEIGHTFROM) &&
           VerifyField<int64_t>(verifier, VT_TIMEFROM) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HASHFROM) &&
           verifier.Verify(hashFrom()) &&
           VerifyField<int32_t>(verifier, VT_GROUPBY) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CLIENTINFO) &&
           verifier.VerifyTable(clientInfo()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TARGETUSERID) &&
           verifier.Verify(targetUserId()) &&
           verifier.EndTable();
  }
  QueryT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct QueryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_userId(flatbuffers::Offset<flatbuffers::String> userId) { fbb_.AddOffset(Query::VT_USERID, userId); }
  void add_workerId(flatbuffers::Offset<flatbuffers::String> workerId) { fbb_.AddOffset(Query::VT_WORKERID, workerId); }
  void add_count(int64_t count) { fbb_.AddElement<int64_t>(Query::VT_COUNT, count, 0); }
  void add_heightFrom(int64_t heightFrom) { fbb_.AddElement<int64_t>(Query::VT_HEIGHTFROM, heightFrom, 0); }
  void add_timeFrom(int64_t timeFrom) { fbb_.AddElement<int64_t>(Query::VT_TIMEFROM, timeFrom, 0); }
  void add_hashFrom(flatbuffers::Offset<flatbuffers::String> hashFrom) { fbb_.AddOffset(Query::VT_HASHFROM, hashFrom); }
  void add_groupBy(GroupByType groupBy) { fbb_.AddElement<int32_t>(Query::VT_GROUPBY, static_cast<int32_t>(groupBy), 0); }
  void add_clientInfo(flatbuffers::Offset<ClientInfo> clientInfo) { fbb_.AddOffset(Query::VT_CLIENTINFO, clientInfo); }
  void add_targetUserId(flatbuffers::Offset<flatbuffers::String> targetUserId) { fbb_.AddOffset(Query::VT_TARGETUSERID, targetUserId); }
  QueryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  QueryBuilder &operator=(const QueryBuilder &);
  flatbuffers::Offset<Query> Finish() {
    auto o = flatbuffers::Offset<Query>(fbb_.EndTable(start_, 9));
    return o;
  }
};

inline flatbuffers::Offset<Query> CreateQuery(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> userId = 0,
    flatbuffers::Offset<flatbuffers::String> workerId = 0,
    int64_t count = 0,
    int64_t heightFrom = 0,
    int64_t timeFrom = 0,
    flatbuffers::Offset<flatbuffers::String> hashFrom = 0,
    GroupByType groupBy = GroupByType_None,
    flatbuffers::Offset<ClientInfo> clientInfo = 0,
    flatbuffers::Offset<flatbuffers::String> targetUserId = 0) {
  QueryBuilder builder_(_fbb);
  builder_.add_timeFrom(timeFrom);
  builder_.add_heightFrom(heightFrom);
  builder_.add_count(count);
  builder_.add_targetUserId(targetUserId);
  builder_.add_clientInfo(clientInfo);
  builder_.add_groupBy(groupBy);
  builder_.add_hashFrom(hashFrom);
  builder_.add_workerId(workerId);
  builder_.add_userId(userId);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query> CreateQueryDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *userId = nullptr,
    const char *workerId = nullptr,
    int64_t count = 0,
    int64_t heightFrom = 0,
    int64_t timeFrom = 0,
    const char *hashFrom = nullptr,
    GroupByType groupBy = GroupByType_None,
    flatbuffers::Offset<ClientInfo> clientInfo = 0,
    const char *targetUserId = nullptr) {
  return CreateQuery(_fbb, userId ? _fbb.CreateString(userId) : 0, workerId ? _fbb.CreateString(workerId) : 0, count, heightFrom, timeFrom, hashFrom ? _fbb.CreateString(hashFrom) : 0, groupBy, clientInfo, targetUserId ? _fbb.CreateString(targetUserId) : 0);
}

inline flatbuffers::Offset<Query> CreateQuery(flatbuffers::FlatBufferBuilder &_fbb, const QueryT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct QueryResultT : public flatbuffers::NativeTable {
  int32_t status;
  std::vector<std::unique_ptr<BlockT>> blocks;
  std::vector<std::unique_ptr<PayoutRecordT>> payouts;
  std::vector<std::unique_ptr<WorkerStatsRecordT>> workers;
  std::unique_ptr<WorkerStatsAggregateT> aggregate;
  std::vector<std::unique_ptr<WorkerStatsAggregateT>> aggregates;
  std::vector<std::unique_ptr<PoolBalanceT>> poolBalances;
  std::unique_ptr<ClientInfoT> info;
};

struct QueryResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATUS = 4,
    VT_BLOCKS = 6,
    VT_PAYOUTS = 8,
    VT_WORKERS = 10,
    VT_AGGREGATE = 12,
    VT_AGGREGATES = 14,
    VT_POOLBALANCES = 16,
    VT_INFO = 18
  };
  int32_t status() const { return GetField<int32_t>(VT_STATUS, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<Block>> *blocks() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Block>> *>(VT_BLOCKS); }
  const flatbuffers::Vector<flatbuffers::Offset<PayoutRecord>> *payouts() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PayoutRecord>> *>(VT_PAYOUTS); }
  const flatbuffers::Vector<flatbuffers::Offset<WorkerStatsRecord>> *workers() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WorkerStatsRecord>> *>(VT_WORKERS); }
  const WorkerStatsAggregate *aggregate() const { return GetPointer<const WorkerStatsAggregate *>(VT_AGGREGATE); }
  const flatbuffers::Vector<flatbuffers::Offset<WorkerStatsAggregate>> *aggregates() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WorkerStatsAggregate>> *>(VT_AGGREGATES); }
  const flatbuffers::Vector<flatbuffers::Offset<PoolBalance>> *poolBalances() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PoolBalance>> *>(VT_POOLBALANCES); }
  const ClientInfo *info() const { return GetPointer<const ClientInfo *>(VT_INFO); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BLOCKS) &&
           verifier.Verify(blocks()) &&
           verifier.VerifyVectorOfTables(blocks()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PAYOUTS) &&
           verifier.Verify(payouts()) &&
           verifier.VerifyVectorOfTables(payouts()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_WORKERS) &&
           verifier.Verify(workers()) &&
           verifier.VerifyVectorOfTables(workers()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_AGGREGATE) &&
           verifier.VerifyTable(aggregate()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_AGGREGATES) &&
           verifier.Verify(aggregates()) &&
           verifier.VerifyVectorOfTables(aggregates()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_POOLBALANCES) &&
           verifier.Verify(poolBalances()) &&
           verifier.VerifyVectorOfTables(poolBalances()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           verifier.EndTable();
  }
  QueryResultT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct QueryResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(int32_t status) { fbb_.AddElement<int32_t>(QueryResult::VT_STATUS, status, 0); }
  void add_blocks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Block>>> blocks) { fbb_.AddOffset(QueryResult::VT_BLOCKS, blocks); }
  void add_payouts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PayoutRecord>>> payouts) { fbb_.AddOffset(QueryResult::VT_PAYOUTS, payouts); }
  void add_workers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WorkerStatsRecord>>> workers) { fbb_.AddOffset(QueryResult::VT_WORKERS, workers); }
  void add_aggregate(flatbuffers::Offset<WorkerStatsAggregate> aggregate) { fbb_.AddOffset(QueryResult::VT_AGGREGATE, aggregate); }
  void add_aggregates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WorkerStatsAggregate>>> aggregates) { fbb_.AddOffset(QueryResult::VT_AGGREGATES, aggregates); }
  void add_poolBalances(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PoolBalance>>> poolBalances) { fbb_.AddOffset(QueryResult::VT_POOLBALANCES, poolBalances); }
  void add_info(flatbuffers::Offset<ClientInfo> info) { fbb_.AddOffset(QueryResult::VT_INFO, info); }
  QueryResultBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  QueryResultBuilder &operator=(const QueryResultBuilder &);
  flatbuffers::Offset<QueryResult> Finish() {
    auto o = flatbuffers::Offset<QueryResult>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<QueryResult> CreateQueryResult(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t status = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Block>>> blocks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PayoutRecord>>> payouts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WorkerStatsRecord>>> workers = 0,
    flatbuffers::Offset<WorkerStatsAggregate> aggregate = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WorkerStatsAggregate>>> aggregates = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PoolBalance>>> poolBalances = 0,
    flatbuffers::Offset<ClientInfo> info = 0) {
  QueryResultBuilder builder_(_fbb);
  builder_.add_info(info);
  builder_.add_poolBalances(poolBalances);
  builder_.add_aggregates(aggregates);
  builder_.add_aggregate(aggregate);
  builder_.add_workers(workers);
  builder_.add_payouts(payouts);
  builder_.add_blocks(blocks);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<QueryResult> CreateQueryResultDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t status = 0,
    const std::vector<flatbuffers::Offset<Block>> *blocks = nullptr,
    const std::vector<flatbuffers::Offset<PayoutRecord>> *payouts = nullptr,
    const std::vector<flatbuffers::Offset<WorkerStatsRecord>> *workers = nullptr,
    flatbuffers::Offset<WorkerStatsAggregate> aggregate = 0,
    const std::vector<flatbuffers::Offset<WorkerStatsAggregate>> *aggregates = nullptr,
    const std::vector<flatbuffers::Offset<PoolBalance>> *poolBalances = nullptr,
    flatbuffers::Offset<ClientInfo> info = 0) {
  return CreateQueryResult(_fbb, status, blocks ? _fbb.CreateVector<flatbuffers::Offset<Block>>(*blocks) : 0, payouts ? _fbb.CreateVector<flatbuffers::Offset<PayoutRecord>>(*payouts) : 0, workers ? _fbb.CreateVector<flatbuffers::Offset<WorkerStatsRecord>>(*workers) : 0, aggregate, aggregates ? _fbb.CreateVector<flatbuffers::Offset<WorkerStatsAggregate>>(*aggregates) : 0, poolBalances ? _fbb.CreateVector<flatbuffers::Offset<PoolBalance>>(*poolBalances) : 0, info);
}

inline flatbuffers::Offset<QueryResult> CreateQueryResult(flatbuffers::FlatBufferBuilder &_fbb, const QueryResultT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct ShareT : public flatbuffers::NativeTable {
  int64_t height;
  std::string userId;
  int64_t value;
  bool isBlock;
  std::string hash;
  int64_t generatedCoins;
};

struct Share FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEIGHT = 4,
    VT_USERID = 6,
    VT_VALUE = 8,
    VT_ISBLOCK = 10,
    VT_HASH = 12,
    VT_GENERATEDCOINS = 14
  };
  int64_t height() const { return GetField<int64_t>(VT_HEIGHT, 0); }
  const flatbuffers::String *userId() const { return GetPointer<const flatbuffers::String *>(VT_USERID); }
  int64_t value() const { return GetField<int64_t>(VT_VALUE, 0); }
  bool isBlock() const { return GetField<uint8_t>(VT_ISBLOCK, 0) != 0; }
  const flatbuffers::String *hash() const { return GetPointer<const flatbuffers::String *>(VT_HASH); }
  int64_t generatedCoins() const { return GetField<int64_t>(VT_GENERATEDCOINS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_HEIGHT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_USERID) &&
           verifier.Verify(userId()) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           VerifyField<uint8_t>(verifier, VT_ISBLOCK) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           VerifyField<int64_t>(verifier, VT_GENERATEDCOINS) &&
           verifier.EndTable();
  }
  ShareT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct ShareBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(int64_t height) { fbb_.AddElement<int64_t>(Share::VT_HEIGHT, height, 0); }
  void add_userId(flatbuffers::Offset<flatbuffers::String> userId) { fbb_.AddOffset(Share::VT_USERID, userId); }
  void add_value(int64_t value) { fbb_.AddElement<int64_t>(Share::VT_VALUE, value, 0); }
  void add_isBlock(bool isBlock) { fbb_.AddElement<uint8_t>(Share::VT_ISBLOCK, static_cast<uint8_t>(isBlock), 0); }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) { fbb_.AddOffset(Share::VT_HASH, hash); }
  void add_generatedCoins(int64_t generatedCoins) { fbb_.AddElement<int64_t>(Share::VT_GENERATEDCOINS, generatedCoins, 0); }
  ShareBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ShareBuilder &operator=(const ShareBuilder &);
  flatbuffers::Offset<Share> Finish() {
    auto o = flatbuffers::Offset<Share>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<Share> CreateShare(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t height = 0,
    flatbuffers::Offset<flatbuffers::String> userId = 0,
    int64_t value = 0,
    bool isBlock = false,
    flatbuffers::Offset<flatbuffers::String> hash = 0,
    int64_t generatedCoins = 0) {
  ShareBuilder builder_(_fbb);
  builder_.add_generatedCoins(generatedCoins);
  builder_.add_value(value);
  builder_.add_height(height);
  builder_.add_hash(hash);
  builder_.add_userId(userId);
  builder_.add_isBlock(isBlock);
  return builder_.Finish();
}

inline flatbuffers::Offset<Share> CreateShareDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t height = 0,
    const char *userId = nullptr,
    int64_t value = 0,
    bool isBlock = false,
    const char *hash = nullptr,
    int64_t generatedCoins = 0) {
  return CreateShare(_fbb, height, userId ? _fbb.CreateString(userId) : 0, value, isBlock, hash ? _fbb.CreateString(hash) : 0, generatedCoins);
}

inline flatbuffers::Offset<Share> CreateShare(flatbuffers::FlatBufferBuilder &_fbb, const ShareT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct StatsT : public flatbuffers::NativeTable {
  std::string userId;
  std::string workerId;
  int64_t power;
  int32_t latency;
  std::string address;
  UnitType type;
  int32_t units;
  int32_t temp;
};

struct Stats FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_USERID = 4,
    VT_WORKERID = 6,
    VT_POWER = 8,
    VT_LATENCY = 10,
    VT_ADDRESS = 12,
    VT_TYPE = 14,
    VT_UNITS = 16,
    VT_TEMP = 18
  };
  const flatbuffers::String *userId() const { return GetPointer<const flatbuffers::String *>(VT_USERID); }
  const flatbuffers::String *workerId() const { return GetPointer<const flatbuffers::String *>(VT_WORKERID); }
  int64_t power() const { return GetField<int64_t>(VT_POWER, 0); }
  int32_t latency() const { return GetField<int32_t>(VT_LATENCY, 0); }
  const flatbuffers::String *address() const { return GetPointer<const flatbuffers::String *>(VT_ADDRESS); }
  UnitType type() const { return static_cast<UnitType>(GetField<int32_t>(VT_TYPE, 0)); }
  int32_t units() const { return GetField<int32_t>(VT_UNITS, 0); }
  int32_t temp() const { return GetField<int32_t>(VT_TEMP, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_USERID) &&
           verifier.Verify(userId()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_WORKERID) &&
           verifier.Verify(workerId()) &&
           VerifyField<int64_t>(verifier, VT_POWER) &&
           VerifyField<int32_t>(verifier, VT_LATENCY) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_UNITS) &&
           VerifyField<int32_t>(verifier, VT_TEMP) &&
           verifier.EndTable();
  }
  StatsT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct StatsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_userId(flatbuffers::Offset<flatbuffers::String> userId) { fbb_.AddOffset(Stats::VT_USERID, userId); }
  void add_workerId(flatbuffers::Offset<flatbuffers::String> workerId) { fbb_.AddOffset(Stats::VT_WORKERID, workerId); }
  void add_power(int64_t power) { fbb_.AddElement<int64_t>(Stats::VT_POWER, power, 0); }
  void add_latency(int32_t latency) { fbb_.AddElement<int32_t>(Stats::VT_LATENCY, latency, 0); }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) { fbb_.AddOffset(Stats::VT_ADDRESS, address); }
  void add_type(UnitType type) { fbb_.AddElement<int32_t>(Stats::VT_TYPE, static_cast<int32_t>(type), 0); }
  void add_units(int32_t units) { fbb_.AddElement<int32_t>(Stats::VT_UNITS, units, 0); }
  void add_temp(int32_t temp) { fbb_.AddElement<int32_t>(Stats::VT_TEMP, temp, 0); }
  StatsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  StatsBuilder &operator=(const StatsBuilder &);
  flatbuffers::Offset<Stats> Finish() {
    auto o = flatbuffers::Offset<Stats>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<Stats> CreateStats(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> userId = 0,
    flatbuffers::Offset<flatbuffers::String> workerId = 0,
    int64_t power = 0,
    int32_t latency = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    UnitType type = UnitType_CPU,
    int32_t units = 0,
    int32_t temp = 0) {
  StatsBuilder builder_(_fbb);
  builder_.add_power(power);
  builder_.add_temp(temp);
  builder_.add_units(units);
  builder_.add_type(type);
  builder_.add_address(address);
  builder_.add_latency(latency);
  builder_.add_workerId(workerId);
  builder_.add_userId(userId);
  return builder_.Finish();
}

inline flatbuffers::Offset<Stats> CreateStatsDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *userId = nullptr,
    const char *workerId = nullptr,
    int64_t power = 0,
    int32_t latency = 0,
    const char *address = nullptr,
    UnitType type = UnitType_CPU,
    int32_t units = 0,
    int32_t temp = 0) {
  return CreateStats(_fbb, userId ? _fbb.CreateString(userId) : 0, workerId ? _fbb.CreateString(workerId) : 0, power, latency, address ? _fbb.CreateString(address) : 0, type, units, temp);
}

inline flatbuffers::Offset<Stats> CreateStats(flatbuffers::FlatBufferBuilder &_fbb, const StatsT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct RoundElementT : public flatbuffers::NativeTable {
  std::string userId;
  int64_t shareValue;
};

struct RoundElement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_USERID = 4,
    VT_SHAREVALUE = 6
  };
  const flatbuffers::String *userId() const { return GetPointer<const flatbuffers::String *>(VT_USERID); }
  int64_t shareValue() const { return GetField<int64_t>(VT_SHAREVALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_USERID) &&
           verifier.Verify(userId()) &&
           VerifyField<int64_t>(verifier, VT_SHAREVALUE) &&
           verifier.EndTable();
  }
  RoundElementT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct RoundElementBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_userId(flatbuffers::Offset<flatbuffers::String> userId) { fbb_.AddOffset(RoundElement::VT_USERID, userId); }
  void add_shareValue(int64_t shareValue) { fbb_.AddElement<int64_t>(RoundElement::VT_SHAREVALUE, shareValue, 0); }
  RoundElementBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RoundElementBuilder &operator=(const RoundElementBuilder &);
  flatbuffers::Offset<RoundElement> Finish() {
    auto o = flatbuffers::Offset<RoundElement>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<RoundElement> CreateRoundElement(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> userId = 0,
    int64_t shareValue = 0) {
  RoundElementBuilder builder_(_fbb);
  builder_.add_shareValue(shareValue);
  builder_.add_userId(userId);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoundElement> CreateRoundElementDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *userId = nullptr,
    int64_t shareValue = 0) {
  return CreateRoundElement(_fbb, userId ? _fbb.CreateString(userId) : 0, shareValue);
}

inline flatbuffers::Offset<RoundElement> CreateRoundElement(flatbuffers::FlatBufferBuilder &_fbb, const RoundElementT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct RoundT : public flatbuffers::NativeTable {
  int64_t height;
  std::string hash;
  int64_t time;
  int64_t availableCoins;
  std::vector<std::unique_ptr<RoundElementT>> elements;
};

struct Round FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEIGHT = 4,
    VT_HASH = 6,
    VT_TIME = 8,
    VT_AVAILABLECOINS = 10,
    VT_ELEMENTS = 12
  };
  int64_t height() const { return GetField<int64_t>(VT_HEIGHT, 0); }
  const flatbuffers::String *hash() const { return GetPointer<const flatbuffers::String *>(VT_HASH); }
  int64_t time() const { return GetField<int64_t>(VT_TIME, 0); }
  int64_t availableCoins() const { return GetField<int64_t>(VT_AVAILABLECOINS, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<RoundElement>> *elements() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RoundElement>> *>(VT_ELEMENTS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_HEIGHT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyField<int64_t>(verifier, VT_AVAILABLECOINS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ELEMENTS) &&
           verifier.Verify(elements()) &&
           verifier.VerifyVectorOfTables(elements()) &&
           verifier.EndTable();
  }
  RoundT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct RoundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(int64_t height) { fbb_.AddElement<int64_t>(Round::VT_HEIGHT, height, 0); }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) { fbb_.AddOffset(Round::VT_HASH, hash); }
  void add_time(int64_t time) { fbb_.AddElement<int64_t>(Round::VT_TIME, time, 0); }
  void add_availableCoins(int64_t availableCoins) { fbb_.AddElement<int64_t>(Round::VT_AVAILABLECOINS, availableCoins, 0); }
  void add_elements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RoundElement>>> elements) { fbb_.AddOffset(Round::VT_ELEMENTS, elements); }
  RoundBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RoundBuilder &operator=(const RoundBuilder &);
  flatbuffers::Offset<Round> Finish() {
    auto o = flatbuffers::Offset<Round>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<Round> CreateRound(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t height = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0,
    int64_t time = 0,
    int64_t availableCoins = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RoundElement>>> elements = 0) {
  RoundBuilder builder_(_fbb);
  builder_.add_availableCoins(availableCoins);
  builder_.add_time(time);
  builder_.add_height(height);
  builder_.add_elements(elements);
  builder_.add_hash(hash);
  return builder_.Finish();
}

inline flatbuffers::Offset<Round> CreateRoundDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t height = 0,
    const char *hash = nullptr,
    int64_t time = 0,
    int64_t availableCoins = 0,
    const std::vector<flatbuffers::Offset<RoundElement>> *elements = nullptr) {
  return CreateRound(_fbb, height, hash ? _fbb.CreateString(hash) : 0, time, availableCoins, elements ? _fbb.CreateVector<flatbuffers::Offset<RoundElement>>(*elements) : 0);
}

inline flatbuffers::Offset<Round> CreateRound(flatbuffers::FlatBufferBuilder &_fbb, const RoundT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct P2PMessageT : public flatbuffers::NativeTable {
  FunctionId functionId;
  DataUnion data;
};

struct P2PMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FUNCTIONID = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  FunctionId functionId() const { return static_cast<FunctionId>(GetField<int32_t>(VT_FUNCTIONID, 0)); }
  Data data_type() const { return static_cast<Data>(GetField<uint8_t>(VT_DATA_TYPE, 0)); }
  const void *data() const { return GetPointer<const void *>(VT_DATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FUNCTIONID) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           VerifyData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  P2PMessageT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct P2PMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_functionId(FunctionId functionId) { fbb_.AddElement<int32_t>(P2PMessage::VT_FUNCTIONID, static_cast<int32_t>(functionId), 0); }
  void add_data_type(Data data_type) { fbb_.AddElement<uint8_t>(P2PMessage::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0); }
  void add_data(flatbuffers::Offset<void> data) { fbb_.AddOffset(P2PMessage::VT_DATA, data); }
  P2PMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  P2PMessageBuilder &operator=(const P2PMessageBuilder &);
  flatbuffers::Offset<P2PMessage> Finish() {
    auto o = flatbuffers::Offset<P2PMessage>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<P2PMessage> CreateP2PMessage(flatbuffers::FlatBufferBuilder &_fbb,
    FunctionId functionId = FunctionId_None,
    Data data_type = Data_NONE,
    flatbuffers::Offset<void> data = 0) {
  P2PMessageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_functionId(functionId);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<P2PMessage> CreateP2PMessage(flatbuffers::FlatBufferBuilder &_fbb, const P2PMessageT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct SignalT : public flatbuffers::NativeTable {
  SignalId signalId;
  DataUnion data;
};

struct Signal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SIGNALID = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  SignalId signalId() const { return static_cast<SignalId>(GetField<int32_t>(VT_SIGNALID, 0)); }
  Data data_type() const { return static_cast<Data>(GetField<uint8_t>(VT_DATA_TYPE, 0)); }
  const void *data() const { return GetPointer<const void *>(VT_DATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SIGNALID) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           VerifyData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  SignalT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct SignalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_signalId(SignalId signalId) { fbb_.AddElement<int32_t>(Signal::VT_SIGNALID, static_cast<int32_t>(signalId), 0); }
  void add_data_type(Data data_type) { fbb_.AddElement<uint8_t>(Signal::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0); }
  void add_data(flatbuffers::Offset<void> data) { fbb_.AddOffset(Signal::VT_DATA, data); }
  SignalBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SignalBuilder &operator=(const SignalBuilder &);
  flatbuffers::Offset<Signal> Finish() {
    auto o = flatbuffers::Offset<Signal>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Signal> CreateSignal(flatbuffers::FlatBufferBuilder &_fbb,
    SignalId signalId = SignalId_None,
    Data data_type = Data_NONE,
    flatbuffers::Offset<void> data = 0) {
  SignalBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_signalId(signalId);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Signal> CreateSignal(flatbuffers::FlatBufferBuilder &_fbb, const SignalT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

inline PoolInfoT *PoolInfo::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new PoolInfoT();
  { auto _e = coin(); if (_e) _o->coin = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<PoolInfo> CreatePoolInfo(flatbuffers::FlatBufferBuilder &_fbb, const PoolInfoT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreatePoolInfo(_fbb,
    _o->coin.size() ? _fbb.CreateString(_o->coin) : 0);
}

inline BlockT *Block::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new BlockT();
  { auto _e = height(); _o->height = _e; };
  { auto _e = bits(); _o->bits = _e; };
  { auto _e = hash(); if (_e) _o->hash = _e->str(); };
  { auto _e = prevhash(); if (_e) _o->prevhash = _e->str(); };
  { auto _e = merkle(); if (_e) _o->merkle = _e->str(); };
  { auto _e = time(); _o->time = _e; };
  { auto _e = hashreserved(); if (_e) _o->hashreserved = _e->str(); };
  { auto _e = equilHashK(); _o->equilHashK = _e; };
  { auto _e = equilHashN(); _o->equilHashN = _e; };
  { auto _e = confirmations(); _o->confirmations = _e; };
  { auto _e = generatedCoins(); _o->generatedCoins = _e; };
  { auto _e = foundBy(); if (_e) _o->foundBy = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<Block> CreateBlock(flatbuffers::FlatBufferBuilder &_fbb, const BlockT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateBlock(_fbb,
    _o->height,
    _o->bits,
    _o->hash.size() ? _fbb.CreateString(_o->hash) : 0,
    _o->prevhash.size() ? _fbb.CreateString(_o->prevhash) : 0,
    _o->merkle.size() ? _fbb.CreateString(_o->merkle) : 0,
    _o->time,
    _o->hashreserved.size() ? _fbb.CreateString(_o->hashreserved) : 0,
    _o->equilHashK,
    _o->equilHashN,
    _o->confirmations,
    _o->generatedCoins,
    _o->foundBy.size() ? _fbb.CreateString(_o->foundBy) : 0);
}

inline BlockTemplateT *BlockTemplate::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new BlockTemplateT();
  { auto _e = prevhash(); if (_e) _o->prevhash = _e->str(); };
  { auto _e = merkle(); if (_e) _o->merkle = _e->str(); };
  { auto _e = bits(); _o->bits = _e; };
  { auto _e = time(); _o->time = _e; };
  { auto _e = extraNonce(); _o->extraNonce = _e; };
  { auto _e = hashreserved(); if (_e) _o->hashreserved = _e->str(); };
  { auto _e = equilHashK(); _o->equilHashK = _e; };
  { auto _e = equilHashN(); _o->equilHashN = _e; };
  return _o;
}

inline flatbuffers::Offset<BlockTemplate> CreateBlockTemplate(flatbuffers::FlatBufferBuilder &_fbb, const BlockTemplateT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateBlockTemplate(_fbb,
    _o->prevhash.size() ? _fbb.CreateString(_o->prevhash) : 0,
    _o->merkle.size() ? _fbb.CreateString(_o->merkle) : 0,
    _o->bits,
    _o->time,
    _o->extraNonce,
    _o->hashreserved.size() ? _fbb.CreateString(_o->hashreserved) : 0,
    _o->equilHashK,
    _o->equilHashN);
}

inline GetBlockByHashReqT *GetBlockByHashReq::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new GetBlockByHashReqT();
  { auto _e = hashes(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->hashes.push_back(_e->Get(_i)->str()); } } };
  return _o;
}

inline flatbuffers::Offset<GetBlockByHashReq> CreateGetBlockByHashReq(flatbuffers::FlatBufferBuilder &_fbb, const GetBlockByHashReqT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateGetBlockByHashReq(_fbb,
    _o->hashes.size() ? _fbb.CreateVectorOfStrings(_o->hashes) : 0);
}

inline GetBlockByHashResultT *GetBlockByHashResult::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new GetBlockByHashResultT();
  { auto _e = blocks(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->blocks.push_back(std::unique_ptr<BlockT>(_e->Get(_i)->UnPack(resolver))); } } };
  return _o;
}

inline flatbuffers::Offset<GetBlockByHashResult> CreateGetBlockByHashResult(flatbuffers::FlatBufferBuilder &_fbb, const GetBlockByHashResultT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateGetBlockByHashResult(_fbb,
    _o->blocks.size() ? _fbb.CreateVector<flatbuffers::Offset<Block>>(_o->blocks.size(), [&](size_t i) { return CreateBlock(_fbb, _o->blocks[i].get(), rehasher); }) : 0);
}

inline ProofOfWorkReqT *ProofOfWorkReq::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new ProofOfWorkReqT();
  { auto _e = height(); _o->height = _e; };
  { auto _e = time(); _o->time = _e; };
  { auto _e = nonce(); if (_e) _o->nonce = _e->str(); };
  { auto _e = extraNonce(); _o->extraNonce = _e; };
  { auto _e = data(); if (_e) _o->data = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<ProofOfWorkReq> CreateProofOfWorkReq(flatbuffers::FlatBufferBuilder &_fbb, const ProofOfWorkReqT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateProofOfWorkReq(_fbb,
    _o->height,
    _o->time,
    _o->nonce.size() ? _fbb.CreateString(_o->nonce) : 0,
    _o->extraNonce,
    _o->data.size() ? _fbb.CreateString(_o->data) : 0);
}

inline ProofOfWorkResultT *ProofOfWorkResult::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new ProofOfWorkResultT();
  { auto _e = result(); _o->result = _e; };
  { auto _e = generatedCoins(); _o->generatedCoins = _e; };
  return _o;
}

inline flatbuffers::Offset<ProofOfWorkResult> CreateProofOfWorkResult(flatbuffers::FlatBufferBuilder &_fbb, const ProofOfWorkResultT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateProofOfWorkResult(_fbb,
    _o->result,
    _o->generatedCoins);
}

inline GetBalanceResultT *GetBalanceResult::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new GetBalanceResultT();
  { auto _e = balance(); _o->balance = _e; };
  { auto _e = immature(); _o->immature = _e; };
  return _o;
}

inline flatbuffers::Offset<GetBalanceResult> CreateGetBalanceResult(flatbuffers::FlatBufferBuilder &_fbb, const GetBalanceResultT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateGetBalanceResult(_fbb,
    _o->balance,
    _o->immature);
}

inline SendMoneyReqT *SendMoneyReq::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new SendMoneyReqT();
  { auto _e = destination(); if (_e) _o->destination = _e->str(); };
  { auto _e = amount(); _o->amount = _e; };
  return _o;
}

inline flatbuffers::Offset<SendMoneyReq> CreateSendMoneyReq(flatbuffers::FlatBufferBuilder &_fbb, const SendMoneyReqT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateSendMoneyReq(_fbb,
    _o->destination.size() ? _fbb.CreateString(_o->destination) : 0,
    _o->amount);
}

inline SendMoneyResultT *SendMoneyResult::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new SendMoneyResultT();
  { auto _e = success(); _o->success = _e; };
  { auto _e = txid(); if (_e) _o->txid = _e->str(); };
  { auto _e = remaining(); _o->remaining = _e; };
  { auto _e = fee(); _o->fee = _e; };
  { auto _e = error(); if (_e) _o->error = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<SendMoneyResult> CreateSendMoneyResult(flatbuffers::FlatBufferBuilder &_fbb, const SendMoneyResultT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateSendMoneyResult(_fbb,
    _o->success,
    _o->txid.size() ? _fbb.CreateString(_o->txid) : 0,
    _o->remaining,
    _o->fee,
    _o->error.size() ? _fbb.CreateString(_o->error) : 0);
}

inline ListUnspentElementT *ListUnspentElement::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new ListUnspentElementT();
  { auto _e = address(); if (_e) _o->address = _e->str(); };
  { auto _e = amount(); _o->amount = _e; };
  { auto _e = confirmations(); _o->confirmations = _e; };
  { auto _e = spendable(); _o->spendable = _e; };
  return _o;
}

inline flatbuffers::Offset<ListUnspentElement> CreateListUnspentElement(flatbuffers::FlatBufferBuilder &_fbb, const ListUnspentElementT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateListUnspentElement(_fbb,
    _o->address.size() ? _fbb.CreateString(_o->address) : 0,
    _o->amount,
    _o->confirmations,
    _o->spendable);
}

inline ZDestinationT *ZDestination::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new ZDestinationT();
  { auto _e = address(); if (_e) _o->address = _e->str(); };
  { auto _e = amount(); _o->amount = _e; };
  { auto _e = memo(); if (_e) _o->memo = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<ZDestination> CreateZDestination(flatbuffers::FlatBufferBuilder &_fbb, const ZDestinationT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateZDestination(_fbb,
    _o->address.size() ? _fbb.CreateString(_o->address) : 0,
    _o->amount,
    _o->memo.size() ? _fbb.CreateString(_o->memo) : 0);
}

inline AsyncOperationStatusT *AsyncOperationStatus::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new AsyncOperationStatusT();
  { auto _e = id(); if (_e) _o->id = _e->str(); };
  { auto _e = state(); _o->state = _e; };
  { auto _e = creationTime(); _o->creationTime = _e; };
  { auto _e = txid(); if (_e) _o->txid = _e->str(); };
  { auto _e = error(); if (_e) _o->error = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<AsyncOperationStatus> CreateAsyncOperationStatus(flatbuffers::FlatBufferBuilder &_fbb, const AsyncOperationStatusT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateAsyncOperationStatus(_fbb,
    _o->id.size() ? _fbb.CreateString(_o->id) : 0,
    _o->state,
    _o->creationTime,
    _o->txid.size() ? _fbb.CreateString(_o->txid) : 0,
    _o->error.size() ? _fbb.CreateString(_o->error) : 0);
}

inline WalletReqT *WalletReq::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new WalletReqT();
  { auto _e = singleAddress(); if (_e) _o->singleAddress = _e->str(); };
  { auto _e = singleAsyncOperationId(); if (_e) _o->singleAsyncOperationId = _e->str(); };
  { auto _e = destinations(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->destinations.push_back(std::unique_ptr<ZDestinationT>(_e->Get(_i)->UnPack(resolver))); } } };
  return _o;
}

inline flatbuffers::Offset<WalletReq> CreateWalletReq(flatbuffers::FlatBufferBuilder &_fbb, const WalletReqT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateWalletReq(_fbb,
    _o->singleAddress.size() ? _fbb.CreateString(_o->singleAddress) : 0,
    _o->singleAsyncOperationId.size() ? _fbb.CreateString(_o->singleAsyncOperationId) : 0,
    _o->destinations.size() ? _fbb.CreateVector<flatbuffers::Offset<ZDestination>>(_o->destinations.size(), [&](size_t i) { return CreateZDestination(_fbb, _o->destinations[i].get(), rehasher); }) : 0);
}

inline WalletResultT *WalletResult::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new WalletResultT();
  { auto _e = balance(); _o->balance = _e; };
  { auto _e = asyncOperationId(); if (_e) _o->asyncOperationId = _e->str(); };
  { auto _e = outs(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outs.push_back(std::unique_ptr<ListUnspentElementT>(_e->Get(_i)->UnPack(resolver))); } } };
  { auto _e = status(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->status.push_back(std::unique_ptr<AsyncOperationStatusT>(_e->Get(_i)->UnPack(resolver))); } } };
  { auto _e = error(); if (_e) _o->error = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<WalletResult> CreateWalletResult(flatbuffers::FlatBufferBuilder &_fbb, const WalletResultT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateWalletResult(_fbb,
    _o->balance,
    _o->asyncOperationId.size() ? _fbb.CreateString(_o->asyncOperationId) : 0,
    _o->outs.size() ? _fbb.CreateVector<flatbuffers::Offset<ListUnspentElement>>(_o->outs.size(), [&](size_t i) { return CreateListUnspentElement(_fbb, _o->outs[i].get(), rehasher); }) : 0,
    _o->status.size() ? _fbb.CreateVector<flatbuffers::Offset<AsyncOperationStatus>>(_o->status.size(), [&](size_t i) { return CreateAsyncOperationStatus(_fbb, _o->status[i].get(), rehasher); }) : 0,
    _o->error.size() ? _fbb.CreateString(_o->error) : 0);
}

inline PoolBalanceT *PoolBalance::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new PoolBalanceT();
  { auto _e = time(); _o->time = _e; };
  { auto _e = balance(); _o->balance = _e; };
  { auto _e = immature(); _o->immature = _e; };
  { auto _e = users(); _o->users = _e; };
  { auto _e = queued(); _o->queued = _e; };
  { auto _e = net(); _o->net = _e; };
  return _o;
}

inline flatbuffers::Offset<PoolBalance> CreatePoolBalance(flatbuffers::FlatBufferBuilder &_fbb, const PoolBalanceT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreatePoolBalance(_fbb,
    _o->time,
    _o->balance,
    _o->immature,
    _o->users,
    _o->queued,
    _o->net);
}

inline ClientInfoT *ClientInfo::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new ClientInfoT();
  { auto _e = balance(); _o->balance = _e; };
  { auto _e = requested(); _o->requested = _e; };
  { auto _e = paid(); _o->paid = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = email(); if (_e) _o->email = _e->str(); };
  { auto _e = minimalPayout(); _o->minimalPayout = _e; };
  return _o;
}

inline flatbuffers::Offset<ClientInfo> CreateClientInfo(flatbuffers::FlatBufferBuilder &_fbb, const ClientInfoT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateClientInfo(_fbb,
    _o->balance,
    _o->requested,
    _o->paid,
    _o->name.size() ? _fbb.CreateString(_o->name) : 0,
    _o->email.size() ? _fbb.CreateString(_o->email) : 0,
    _o->minimalPayout);
}

inline PayoutRecordT *PayoutRecord::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new PayoutRecordT();
  { auto _e = timeLabel(); if (_e) _o->timeLabel = _e->str(); };
  { auto _e = time(); _o->time = _e; };
  { auto _e = value(); _o->value = _e; };
  { auto _e = txid(); if (_e) _o->txid = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<PayoutRecord> CreatePayoutRecord(flatbuffers::FlatBufferBuilder &_fbb, const PayoutRecordT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreatePayoutRecord(_fbb,
    _o->timeLabel.size() ? _fbb.CreateString(_o->timeLabel) : 0,
    _o->time,
    _o->value,
    _o->txid.size() ? _fbb.CreateString(_o->txid) : 0);
}

inline WorkerStatsRecordT *WorkerStatsRecord::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new WorkerStatsRecordT();
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = time(); _o->time = _e; };
  { auto _e = address(); if (_e) _o->address = _e->str(); };
  { auto _e = power(); _o->power = _e; };
  { auto _e = latency(); _o->latency = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = units(); _o->units = _e; };
  { auto _e = temp(); _o->temp = _e; };
  return _o;
}

inline flatbuffers::Offset<WorkerStatsRecord> CreateWorkerStatsRecord(flatbuffers::FlatBufferBuilder &_fbb, const WorkerStatsRecordT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateWorkerStatsRecord(_fbb,
    _o->name.size() ? _fbb.CreateString(_o->name) : 0,
    _o->time,
    _o->address.size() ? _fbb.CreateString(_o->address) : 0,
    _o->power,
    _o->latency,
    _o->type,
    _o->units,
    _o->temp);
}

inline WorkerStatsAggregateT *WorkerStatsAggregate::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new WorkerStatsAggregateT();
  { auto _e = time(); _o->time = _e; };
  { auto _e = clients(); _o->clients = _e; };
  { auto _e = workers(); _o->workers = _e; };
  { auto _e = cpus(); _o->cpus = _e; };
  { auto _e = gpus(); _o->gpus = _e; };
  { auto _e = asics(); _o->asics = _e; };
  { auto _e = other(); _o->other = _e; };
  { auto _e = avgerageLatency(); _o->avgerageLatency = _e; };
  { auto _e = power(); _o->power = _e; };
  return _o;
}

inline flatbuffers::Offset<WorkerStatsAggregate> CreateWorkerStatsAggregate(flatbuffers::FlatBufferBuilder &_fbb, const WorkerStatsAggregateT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateWorkerStatsAggregate(_fbb,
    _o->time,
    _o->clients,
    _o->workers,
    _o->cpus,
    _o->gpus,
    _o->asics,
    _o->other,
    _o->avgerageLatency,
    _o->power);
}

inline QueryT *Query::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new QueryT();
  { auto _e = userId(); if (_e) _o->userId = _e->str(); };
  { auto _e = workerId(); if (_e) _o->workerId = _e->str(); };
  { auto _e = count(); _o->count = _e; };
  { auto _e = heightFrom(); _o->heightFrom = _e; };
  { auto _e = timeFrom(); _o->timeFrom = _e; };
  { auto _e = hashFrom(); if (_e) _o->hashFrom = _e->str(); };
  { auto _e = groupBy(); _o->groupBy = _e; };
  { auto _e = clientInfo(); if (_e) _o->clientInfo = std::unique_ptr<ClientInfoT>(_e->UnPack(resolver)); };
  { auto _e = targetUserId(); if (_e) _o->targetUserId = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<Query> CreateQuery(flatbuffers::FlatBufferBuilder &_fbb, const QueryT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateQuery(_fbb,
    _o->userId.size() ? _fbb.CreateString(_o->userId) : 0,
    _o->workerId.size() ? _fbb.CreateString(_o->workerId) : 0,
    _o->count,
    _o->heightFrom,
    _o->timeFrom,
    _o->hashFrom.size() ? _fbb.CreateString(_o->hashFrom) : 0,
    _o->groupBy,
    _o->clientInfo ? CreateClientInfo(_fbb, _o->clientInfo.get(), rehasher) : 0,
    _o->targetUserId.size() ? _fbb.CreateString(_o->targetUserId) : 0);
}

inline QueryResultT *QueryResult::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new QueryResultT();
  { auto _e = status(); _o->status = _e; };
  { auto _e = blocks(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->blocks.push_back(std::unique_ptr<BlockT>(_e->Get(_i)->UnPack(resolver))); } } };
  { auto _e = payouts(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->payouts.push_back(std::unique_ptr<PayoutRecordT>(_e->Get(_i)->UnPack(resolver))); } } };
  { auto _e = workers(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->workers.push_back(std::unique_ptr<WorkerStatsRecordT>(_e->Get(_i)->UnPack(resolver))); } } };
  { auto _e = aggregate(); if (_e) _o->aggregate = std::unique_ptr<WorkerStatsAggregateT>(_e->UnPack(resolver)); };
  { auto _e = aggregates(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aggregates.push_back(std::unique_ptr<WorkerStatsAggregateT>(_e->Get(_i)->UnPack(resolver))); } } };
  { auto _e = poolBalances(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->poolBalances.push_back(std::unique_ptr<PoolBalanceT>(_e->Get(_i)->UnPack(resolver))); } } };
  { auto _e = info(); if (_e) _o->info = std::unique_ptr<ClientInfoT>(_e->UnPack(resolver)); };
  return _o;
}

inline flatbuffers::Offset<QueryResult> CreateQueryResult(flatbuffers::FlatBufferBuilder &_fbb, const QueryResultT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateQueryResult(_fbb,
    _o->status,
    _o->blocks.size() ? _fbb.CreateVector<flatbuffers::Offset<Block>>(_o->blocks.size(), [&](size_t i) { return CreateBlock(_fbb, _o->blocks[i].get(), rehasher); }) : 0,
    _o->payouts.size() ? _fbb.CreateVector<flatbuffers::Offset<PayoutRecord>>(_o->payouts.size(), [&](size_t i) { return CreatePayoutRecord(_fbb, _o->payouts[i].get(), rehasher); }) : 0,
    _o->workers.size() ? _fbb.CreateVector<flatbuffers::Offset<WorkerStatsRecord>>(_o->workers.size(), [&](size_t i) { return CreateWorkerStatsRecord(_fbb, _o->workers[i].get(), rehasher); }) : 0,
    _o->aggregate ? CreateWorkerStatsAggregate(_fbb, _o->aggregate.get(), rehasher) : 0,
    _o->aggregates.size() ? _fbb.CreateVector<flatbuffers::Offset<WorkerStatsAggregate>>(_o->aggregates.size(), [&](size_t i) { return CreateWorkerStatsAggregate(_fbb, _o->aggregates[i].get(), rehasher); }) : 0,
    _o->poolBalances.size() ? _fbb.CreateVector<flatbuffers::Offset<PoolBalance>>(_o->poolBalances.size(), [&](size_t i) { return CreatePoolBalance(_fbb, _o->poolBalances[i].get(), rehasher); }) : 0,
    _o->info ? CreateClientInfo(_fbb, _o->info.get(), rehasher) : 0);
}

inline ShareT *Share::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new ShareT();
  { auto _e = height(); _o->height = _e; };
  { auto _e = userId(); if (_e) _o->userId = _e->str(); };
  { auto _e = value(); _o->value = _e; };
  { auto _e = isBlock(); _o->isBlock = _e; };
  { auto _e = hash(); if (_e) _o->hash = _e->str(); };
  { auto _e = generatedCoins(); _o->generatedCoins = _e; };
  return _o;
}

inline flatbuffers::Offset<Share> CreateShare(flatbuffers::FlatBufferBuilder &_fbb, const ShareT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateShare(_fbb,
    _o->height,
    _o->userId.size() ? _fbb.CreateString(_o->userId) : 0,
    _o->value,
    _o->isBlock,
    _o->hash.size() ? _fbb.CreateString(_o->hash) : 0,
    _o->generatedCoins);
}

inline StatsT *Stats::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new StatsT();
  { auto _e = userId(); if (_e) _o->userId = _e->str(); };
  { auto _e = workerId(); if (_e) _o->workerId = _e->str(); };
  { auto _e = power(); _o->power = _e; };
  { auto _e = latency(); _o->latency = _e; };
  { auto _e = address(); if (_e) _o->address = _e->str(); };
  { auto _e = type(); _o->type = _e; };
  { auto _e = units(); _o->units = _e; };
  { auto _e = temp(); _o->temp = _e; };
  return _o;
}

inline flatbuffers::Offset<Stats> CreateStats(flatbuffers::FlatBufferBuilder &_fbb, const StatsT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateStats(_fbb,
    _o->userId.size() ? _fbb.CreateString(_o->userId) : 0,
    _o->workerId.size() ? _fbb.CreateString(_o->workerId) : 0,
    _o->power,
    _o->latency,
    _o->address.size() ? _fbb.CreateString(_o->address) : 0,
    _o->type,
    _o->units,
    _o->temp);
}

inline RoundElementT *RoundElement::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new RoundElementT();
  { auto _e = userId(); if (_e) _o->userId = _e->str(); };
  { auto _e = shareValue(); _o->shareValue = _e; };
  return _o;
}

inline flatbuffers::Offset<RoundElement> CreateRoundElement(flatbuffers::FlatBufferBuilder &_fbb, const RoundElementT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateRoundElement(_fbb,
    _o->userId.size() ? _fbb.CreateString(_o->userId) : 0,
    _o->shareValue);
}

inline RoundT *Round::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new RoundT();
  { auto _e = height(); _o->height = _e; };
  { auto _e = hash(); if (_e) _o->hash = _e->str(); };
  { auto _e = time(); _o->time = _e; };
  { auto _e = availableCoins(); _o->availableCoins = _e; };
  { auto _e = elements(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->elements.push_back(std::unique_ptr<RoundElementT>(_e->Get(_i)->UnPack(resolver))); } } };
  return _o;
}

inline flatbuffers::Offset<Round> CreateRound(flatbuffers::FlatBufferBuilder &_fbb, const RoundT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateRound(_fbb,
    _o->height,
    _o->hash.size() ? _fbb.CreateString(_o->hash) : 0,
    _o->time,
    _o->availableCoins,
    _o->elements.size() ? _fbb.CreateVector<flatbuffers::Offset<RoundElement>>(_o->elements.size(), [&](size_t i) { return CreateRoundElement(_fbb, _o->elements[i].get(), rehasher); }) : 0);
}

inline P2PMessageT *P2PMessage::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new P2PMessageT();
  { auto _e = functionId(); _o->functionId = _e; };
  { auto _e = data_type(); _o->data.type = _e; };
  { auto _e = data(); if (_e) _o->data.table = DataUnion::UnPack(_e, data_type(), resolver); };
  return _o;
}

inline flatbuffers::Offset<P2PMessage> CreateP2PMessage(flatbuffers::FlatBufferBuilder &_fbb, const P2PMessageT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateP2PMessage(_fbb,
    _o->functionId,
    _o->data.type,
    _o->data.Pack(_fbb));
}

inline SignalT *Signal::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new SignalT();
  { auto _e = signalId(); _o->signalId = _e; };
  { auto _e = data_type(); _o->data.type = _e; };
  { auto _e = data(); if (_e) _o->data.table = DataUnion::UnPack(_e, data_type(), resolver); };
  return _o;
}

inline flatbuffers::Offset<Signal> CreateSignal(flatbuffers::FlatBufferBuilder &_fbb, const SignalT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateSignal(_fbb,
    _o->signalId,
    _o->data.type,
    _o->data.Pack(_fbb));
}

inline bool VerifyData(flatbuffers::Verifier &verifier, const void *union_obj, Data type) {
  switch (type) {
    case Data_NONE: return true;
    case Data_PoolInfo: return verifier.VerifyTable(reinterpret_cast<const PoolInfo *>(union_obj));
    case Data_Block: return verifier.VerifyTable(reinterpret_cast<const Block *>(union_obj));
    case Data_BlockTemplate: return verifier.VerifyTable(reinterpret_cast<const BlockTemplate *>(union_obj));
    case Data_GetBlockByHashReq: return verifier.VerifyTable(reinterpret_cast<const GetBlockByHashReq *>(union_obj));
    case Data_ProofOfWorkReq: return verifier.VerifyTable(reinterpret_cast<const ProofOfWorkReq *>(union_obj));
    case Data_SendMoneyReq: return verifier.VerifyTable(reinterpret_cast<const SendMoneyReq *>(union_obj));
    case Data_WalletReq: return verifier.VerifyTable(reinterpret_cast<const WalletReq *>(union_obj));
    case Data_Query: return verifier.VerifyTable(reinterpret_cast<const Query *>(union_obj));
    case Data_QueryResult: return verifier.VerifyTable(reinterpret_cast<const QueryResult *>(union_obj));
    case Data_Share: return verifier.VerifyTable(reinterpret_cast<const Share *>(union_obj));
    case Data_Stats: return verifier.VerifyTable(reinterpret_cast<const Stats *>(union_obj));
    default: return false;
  }
}

inline flatbuffers::NativeTable *DataUnion::UnPack(const void *union_obj, Data type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Data_NONE: return nullptr;
    case Data_PoolInfo: return reinterpret_cast<const PoolInfo *>(union_obj)->UnPack(resolver);
    case Data_Block: return reinterpret_cast<const Block *>(union_obj)->UnPack(resolver);
    case Data_BlockTemplate: return reinterpret_cast<const BlockTemplate *>(union_obj)->UnPack(resolver);
    case Data_GetBlockByHashReq: return reinterpret_cast<const GetBlockByHashReq *>(union_obj)->UnPack(resolver);
    case Data_ProofOfWorkReq: return reinterpret_cast<const ProofOfWorkReq *>(union_obj)->UnPack(resolver);
    case Data_SendMoneyReq: return reinterpret_cast<const SendMoneyReq *>(union_obj)->UnPack(resolver);
    case Data_WalletReq: return reinterpret_cast<const WalletReq *>(union_obj)->UnPack(resolver);
    case Data_Query: return reinterpret_cast<const Query *>(union_obj)->UnPack(resolver);
    case Data_QueryResult: return reinterpret_cast<const QueryResult *>(union_obj)->UnPack(resolver);
    case Data_Share: return reinterpret_cast<const Share *>(union_obj)->UnPack(resolver);
    case Data_Stats: return reinterpret_cast<const Stats *>(union_obj)->UnPack(resolver);
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> DataUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *rehasher) const {
  switch (type) {
    case Data_NONE: return 0;
    case Data_PoolInfo: return CreatePoolInfo(_fbb, reinterpret_cast<const PoolInfoT *>(table), rehasher).Union();
    case Data_Block: return CreateBlock(_fbb, reinterpret_cast<const BlockT *>(table), rehasher).Union();
    case Data_BlockTemplate: return CreateBlockTemplate(_fbb, reinterpret_cast<const BlockTemplateT *>(table), rehasher).Union();
    case Data_GetBlockByHashReq: return CreateGetBlockByHashReq(_fbb, reinterpret_cast<const GetBlockByHashReqT *>(table), rehasher).Union();
    case Data_ProofOfWorkReq: return CreateProofOfWorkReq(_fbb, reinterpret_cast<const ProofOfWorkReqT *>(table), rehasher).Union();
    case Data_SendMoneyReq: return CreateSendMoneyReq(_fbb, reinterpret_cast<const SendMoneyReqT *>(table), rehasher).Union();
    case Data_WalletReq: return CreateWalletReq(_fbb, reinterpret_cast<const WalletReqT *>(table), rehasher).Union();
    case Data_Query: return CreateQuery(_fbb, reinterpret_cast<const QueryT *>(table), rehasher).Union();
    case Data_QueryResult: return CreateQueryResult(_fbb, reinterpret_cast<const QueryResultT *>(table), rehasher).Union();
    case Data_Share: return CreateShare(_fbb, reinterpret_cast<const ShareT *>(table), rehasher).Union();
    case Data_Stats: return CreateStats(_fbb, reinterpret_cast<const StatsT *>(table), rehasher).Union();
    default: return 0;
  }
}

inline DataUnion::~DataUnion() {
  switch (type) {
    case Data_PoolInfo: delete reinterpret_cast<PoolInfoT *>(table); break;
    case Data_Block: delete reinterpret_cast<BlockT *>(table); break;
    case Data_BlockTemplate: delete reinterpret_cast<BlockTemplateT *>(table); break;
    case Data_GetBlockByHashReq: delete reinterpret_cast<GetBlockByHashReqT *>(table); break;
    case Data_ProofOfWorkReq: delete reinterpret_cast<ProofOfWorkReqT *>(table); break;
    case Data_SendMoneyReq: delete reinterpret_cast<SendMoneyReqT *>(table); break;
    case Data_WalletReq: delete reinterpret_cast<WalletReqT *>(table); break;
    case Data_Query: delete reinterpret_cast<QueryT *>(table); break;
    case Data_QueryResult: delete reinterpret_cast<QueryResultT *>(table); break;
    case Data_Share: delete reinterpret_cast<ShareT *>(table); break;
    case Data_Stats: delete reinterpret_cast<StatsT *>(table); break;
    default:;
  }
}

inline const P2PMessage *GetP2PMessage(const void *buf) {
  return flatbuffers::GetRoot<P2PMessage>(buf);
}

inline bool VerifyP2PMessageBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<P2PMessage>(nullptr);
}

inline void FinishP2PMessageBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<P2PMessage> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<P2PMessageT> UnPackP2PMessage(const void *buf, const flatbuffers::resolver_function_t *resolver = nullptr) {
  return std::unique_ptr<P2PMessageT>(GetP2PMessage(buf)->UnPack(resolver));
}

#endif  // FLATBUFFERS_GENERATED_POOL_H_
